<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>鸿蒙开发实践</title>
      <link href="/2023/12/02/%E9%B8%BF%E8%92%99%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/12/02/%E9%B8%BF%E8%92%99%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="鸿蒙开发"><a href="#鸿蒙开发" class="headerlink" title="鸿蒙开发"></a>鸿蒙开发</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着鸿蒙系统宣布删除android代码，鸿蒙系统开始进入了全新的开发模式，HarmonyOS的版本也更新到了3.1版本，新的ArkTS是基于TS扩展出来的，所以对前端很友好</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>开发工具：DevEco Studio</p><p>首先需要去<a href="https://developer.harmonyos.com/cn/develop/deveco-studio/">官网</a>下载基于IDE的开发工具DevEco Studio</p><p>安装之后需要对Node环境、Ohpm的安装路径机型配置<img src="https://snow-cdn-1259430989.cos.ap-beijing.myqcloud.com/blog/%E9%85%8D%E7%BD%AE1.png" alt="配置1"><img src="https://snow-cdn-1259430989.cos.ap-beijing.myqcloud.com/blog/%E9%85%8D%E7%BD%AE2.png" alt="配置2"><br>然后需要下载HarmonyOS的SDK<img src="https://snow-cdn-1259430989.cos.ap-beijing.myqcloud.com/blog/%E9%85%8D%E7%BD%AE3.png" alt="配置3"></p><p>整个DevEco Studio是基于IntelliJ实现的，所以熟悉westorm的话会如鱼得水</p><h2 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h2><p>创建项目的时候会要求我们选择一个模版<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ba87c330b124bf4a8222951bd5ecf59~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1242&h=853&s=53526&e=png&b=3e4042" alt="模版"></p><p>然后需要选择我们需要的配置<br><img src="https://snow-cdn-1259430989.cos.ap-beijing.myqcloud.com/blog/%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA1.png" alt="Alt text"><br>这里我们需要选择Stage模型和ArkTS语言以及适用设备类型，FA是早期鸿蒙支持的模型，支持直接使用hml、css、js进行开发，这里更推荐使用最新的Stage模型</p><p>然后经过一些列的加载等待一个空的项目就已经创建好了，接下来就进入到了我们的编码阶段</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><ul><li>AppScope中存放应用全局所需要的资源文件，其中element文件夹主要存放公共的字符串、布局文件等资源, media存放全局公共的多媒体资源文件。</li><li>entry是应用的主模块，存放HarmonyOS应用的代码、资源等。</li><li>oh_modules是工程的依赖包，存放工程依赖的源文件。</li><li>build-profile.json5是工程级配置信息，包括签名、产品配置等。</li><li>hvigorfile.ts是工程级编译构建任务脚本，hvigor是基于任务管理机制实现的一款全新的自动化构建工具，主要提供任务注册编排，工程模型管理、配置管理等核心能力。</li><li>oh-package.json5是工程级依赖配置文件，用于记录引入包的配置信息。</li></ul><h2 id="Device真机调试"><a href="#Device真机调试" class="headerlink" title="Device真机调试"></a>Device真机调试</h2><p><img src="https://snow-cdn-1259430989.cos.ap-beijing.myqcloud.com/blog/%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%951.png" alt="Alt text"></p><p>如图我们开发程序的时候肯定需要进行实机调试，但是我们又不可能直接买一部HarmonyOS系统的手机来专门调试，所以可以使用官方提供的模拟器</p><p>首先点击Device Manager -&gt; + New Emulator -&gt; 选择需要的设备 -&gt; next下载指定的系统包 -&gt; 配置系统，包括ROM、RAM和CPU核数</p><p>配置信息的时候越高配置调试的时候越流畅，它会共享你电脑的硬件设备。</p><p><img src="https://snow-cdn-1259430989.cos.ap-beijing.myqcloud.com/blog/%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%952.png" alt="Alt text"><br><img src="https://snow-cdn-1259430989.cos.ap-beijing.myqcloud.com/blog/%E6%A8%A1%E6%8B%9F%E5%99%A81.png" alt="Alt text"></p><p>出现手机界面以后，然后操作开机以后我们的代码就可以在模拟机上面进行调试了</p><h2 id="ArkTS"><a href="#ArkTS" class="headerlink" title="ArkTS"></a>ArkTS</h2><p>ArkTs是基于TypeScript拓展了声明式UI、状态管理、并发任务等能力所创造出来的</p><p>ArkTS的声明式语法能更加直观地看出页面结构，能够更快速地进行开发<br><img src="https://snow-cdn-1259430989.cos.ap-beijing.myqcloud.com/blog/%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84.png" alt="Alt text"></p><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>装饰器是一个赋予类、结构、方法或者变量特殊意义的写法</p><p>@Entry: 声明应用的默认入口<br>@Component: 声明一个可重用组件，即一个自定义的结构体<br>@State: 声明一个触发器，如上图中声明的isChange，当它发生改变时就会触发这个变量对应的组件，类似于Vue中的ref()<br>@Link: 装饰的变量可以和父组件的@State变量建立双向数据绑定，需要注意@Link变量不能在组件内部进行初始化<br>@Builder: 装饰的方法用于定义组件的声明式UI描述，在一个自定义组件内快速生成布局内容。<br>@BuilderParam: 用来装饰指向@Builder方法的变量，可以在初始化自定义组件的时候对这个变量进行赋值</p><h3 id="UI描述"><a href="#UI描述" class="headerlink" title="UI描述"></a>UI描述</h3><p>build()：声明式地描述自定义组件的UI结构<br>内置组件：</p><ul><li>Row: 水平方向的布局容器</li><li>Colunm: 垂直方向的布局容器</li></ul><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>系统提供了足够的基础组件例如Text、Button、Image、TextInput等，还有一些容器组件Column、Row、Stack、List等</p><p>我们也可以使用上述基础组件自己封装需要的自定义组件、</p><p>自定义组件可以通过import的方式导入</p><p>自定义组件的生命周期是 创建 -&gt; aboutToAppear -&gt; aboutToDisappear() -&gt; 销毁<br><img src="https://snow-cdn-1259430989.cos.ap-beijing.myqcloud.com/blog/%E7%BB%84%E4%BB%B6.png" alt="Alt text"></p><h3 id="属性方法"><a href="#属性方法" class="headerlink" title="属性方法"></a>属性方法</h3><p>属性方法用于设置组件的属性，声明式的css</p><h3 id="事件方法"><a href="#事件方法" class="headerlink" title="事件方法"></a>事件方法</h3><p>事件方法用于设置组件对事件的响应逻辑</p><h3 id="页面生命周期"><a href="#页面生命周期" class="headerlink" title="页面生命周期"></a>页面生命周期</h3><p>创建 -&gt; aboutToAppear -&gt; onPageShow() -&gt; onBackPress() -&gt; onPageHide() -&gt; aboutToDisappear() -&gt; 销毁<br><img src="https://snow-cdn-1259430989.cos.ap-beijing.myqcloud.com/blog/%E9%A1%B5%E9%9D%A2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="Alt text"></p><p>其中onPageShow在从开启程序以及从系统后台返回时都会触发，onPageHide同理</p><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p><strong>循环</strong>：使用ForEach可以渲染迭代数组<br>ForEach(Array, function),，其中function是一个生成器函数可以在内部包含想要渲染的组件内容</p><p><strong>$r</strong>: 语法糖代表调用resource的资源</p><p>参考案例：<a href="https://developer.huawei.com/consumer/cn/training/course/slightMooc/C101667356568959645?ha_linker=eyJ0cyI6MTcwMTQxMTY3MjYyMiwiaWQiOiI3ZjJlYWJhNWZlZGQwYjk3NzU3YWY1ZWFmZjY5MDc0YiJ9">代办列表</a></p><h2 id="UIAbility（应用程序入口）"><a href="#UIAbility（应用程序入口）" class="headerlink" title="UIAbility（应用程序入口）"></a>UIAbility（应用程序入口）</h2><p>UIAbility是一种包含用户界面的应用组件，用于与用户进行交互，同时也是系统调度的单元</p><p>两个页面间的交互可以导入router来进行跳转操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import router from &#x27;@ohos.router&#x27;;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">build() &#123;</span><br><span class="line">  Row() &#123;</span><br><span class="line">    Button(&#x27;Nexy&#x27;)</span><br><span class="line">      .onClick(() =&gt; &#123;</span><br><span class="line">        router.pushUrl(&#123;</span><br><span class="line">          url: &#x27;pages/index2&#x27;,</span><br><span class="line">          params: &#123;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要数据传输那就需要使用router.pushUrl(url, params)的第二个参数prams进行传递，接收页面可以通过router.getParams进行接收</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// page1 传值</span><br><span class="line">router.pushUrl(&#123;</span><br><span class="line">  url: &#x27;pages/index2&#x27;,</span><br><span class="line">  params: &#123;</span><br><span class="line">    src: &#x27;111&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// page2 取值</span><br><span class="line">@State src: string = router.getParams()?.[&#x27;src&#x27;];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可以使用router.back()方法返回上一个页面</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>UIAbility的生命周期如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Create -&gt; WindowStageCreate -&gt; Foreground &lt;-&gt; Background -&gt; WindowStageDestory -&gt; Destory </span><br></pre></td></tr></table></figure><p><img src="https://snow-cdn-1259430989.cos.ap-beijing.myqcloud.com/blog/UIAbility%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="Alt text"></p><h3 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h3><p>UIAbility当前支持singleton（单实例模式）、multiton（多实例模式）和specified（指定实例模式）3种启动模式</p><ul><li>singleton（单实例模式）: 当用户打开浏览器或者新闻等应用，并浏览访问相关内容后，回到桌面，再次打开该应用，显示的仍然是用户当前访问的界面，也是默认情况下的启动模式。</li><li>multiton（多实例模式）: 用户在使用分屏功能时，希望使用两个不同应用（例如备忘录应用和图库应用）之间进行分屏，也希望能使用同一个应用（例如备忘录应用自身）进行分屏。</li><li>specified（指定实例模式）: 用户打开文档应用，从文档应用中打开一个文档内容，回到文档应用，继续打开同一个文档，希望打开的还是同一个文档内容；以及在文档应用中新建一个新的文档，每次新建文档，希望打开的都是一个新的空白文档内容。</li></ul><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>我们又两种调试方法，一种是直接使用编辑器右侧的preview进行预览<br><img src="https://snow-cdn-1259430989.cos.ap-beijing.myqcloud.com/blog/%E8%B0%83%E8%AF%951.png" alt="Alt text"><br>这里我们预览的文件必须是使用@Entry设置的app入口页面，否则编辑器也会出现警告提示</p><p>第二种办法就是直接选择我们的模拟器进行实机运行<br><img src="https://snow-cdn-1259430989.cos.ap-beijing.myqcloud.com/blog/%E8%B0%83%E8%AF%952.png" alt="Alt text"></p>]]></content>
      
      
      <categories>
          
          <category> 鸿蒙 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 鸿蒙 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二进制</title>
      <link href="/2023/10/13/%E8%B5%B0%E8%BF%9B%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
      <url>/2023/10/13/%E8%B5%B0%E8%BF%9B%E4%BA%8C%E8%BF%9B%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="二进制计算"><a href="#二进制计算" class="headerlink" title="二进制计算"></a>二进制计算</h1><p>计算机的世界里缺少不了二进制的存在，我们总听到计算机是0和1组成的，而这两个数字恰恰就是二进制的必备元素 </p><h2 id="十进制与二进制"><a href="#十进制与二进制" class="headerlink" title="十进制与二进制"></a>十进制与二进制</h2><ul><li><p>十进制：回到小学初识数字的时候，从小到大接触的数字中从0数到9，比9大一个数就要进一位也就是10，这就是十进制，即逢10进1，这就是十进制</p></li><li><p>二进制：从0开始数，当数到2时就进一位，即逢2进一，例如： 0，1，10，11，100，101，110,111。这就是二进制</p></li></ul><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p>初次接触二进制总会觉得别扭，例如101，这个数字在十进制中是<strong>一百零一</strong>，在二进制中他就代表了<strong>数字5</strong>，这时候脑袋上可能会有大大的问号，怎么就知道他就是5呢，这里就要说一下进制转换了</p><p>当我们已知一个十进制数字的时候怎么转换成二进制呢，（余数法）方法如下：</p><ol><li>5 ÷ 2 &#x3D; 2 … 1</li><li>2 ÷ 2 &#x3D; 1 … 0</li><li>1 ÷ 2 &#x3D; 0 … 1</li></ol><p>我们从上到下将余数拼接就是5（十进制）&#x3D; 101（二进制）</p><p>如果这里还是没看懂那可以看接下来的解释</p><p>我们从0开始数（<strong>下面示例中序号为十进制，计算为二进制</strong>）</p><ol start="0"><li>0</li><li>0 + 1 &#x3D; 1</li><li>1 + 1 &#x3D; 10(二进制)，二进制逢2进1，此处进位即10(二进制)</li><li>10 + 1 &#x3D; 11</li><li>11 + 1 &#x3D; 100，二进制逢2进1，进位后为20，同理进位即100</li><li>100 + 1 &#x3D; 101</li></ol><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>熟练转换以后我们可以把二进制和十进制做一个对比：</p><p><img src="https://snow-cdn-1259430989.cos.ap-beijing.myqcloud.com/blog/%E4%BA%8C%E8%BF%9B%E5%88%B61.jpg" alt="十进制与二进制"></p><p>将二进制中只有1和0的情况提取出来，就行成了下面这样：</p><p><img src="https://snow-cdn-1259430989.cos.ap-beijing.myqcloud.com/blog/%E4%BA%8C%E8%BF%9B%E5%88%B62.jpg" alt="十进制与二进制"></p><p>这个时候把列表反过来看：</p><p><img src="https://snow-cdn-1259430989.cos.ap-beijing.myqcloud.com/blog/%E4%BA%8C%E8%BF%9B%E5%88%B63.jpg" alt="十进制与二进制"></p><p>把这个对照变成二进制再看一下：</p><p><img src="https://snow-cdn-1259430989.cos.ap-beijing.myqcloud.com/blog/%E4%BA%8C%E8%BF%9B%E5%88%B64.png" alt="十进制与二进制"></p><p>回过头再看一下最一开始的例子即 5(十进制) 转换为二进制 101：</p><p><img src="https://snow-cdn-1259430989.cos.ap-beijing.myqcloud.com/blog/%E4%BA%8C%E8%BF%9B%E5%88%B65.png" alt="十进制与二进制"></p><p>以上就是十进制转二进制全过程了</p><p>而二进制转换十进制就是将表中对应的数字上下相乘，然后结果相加即可</p><h2 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h2><p>在计算机系统中 <strong>字节(byte)</strong> 是最基础的计量单位，一个字节代表了一个8位长的二进制数字，每四个字节拼在一起代表了一个字</p><p>简单标识就是如下面原码所示，00000000这个八个数字组成一个字节，四个字节组成了一个数字5，即</p><pre><code>00000000 00000000 00000000 00000101 </code></pre><h2 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h2><p>原码：即原数字转换为二进制后的二进制数</p><p>5的原码为</p><pre><code>00000000 00000000 00000000 00000101</code></pre><h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><p>反码：反码即对原码进行取反，将所有的0换为1，所有的1换为0</p><p>5的反码为</p><pre><code>11111111 11111111 11111111 11111010</code></pre><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>补码：补码是反码+1</p><p>所以上述的补码为</p><pre><code>11111111 11111111 11111111 11111010 + 1 =11111111 11111111 11111111 11111011</code></pre><p>补码在二进制中主要表示一个整数的负数</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stable Diffusion体验（本地部署篇）</title>
      <link href="/2023/07/17/Stable%20Diffusion%E4%BD%93%E9%AA%8C%EF%BC%88%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E7%AF%87%EF%BC%89/"/>
      <url>/2023/07/17/Stable%20Diffusion%E4%BD%93%E9%AA%8C%EF%BC%88%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E7%AF%87%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Stable-Diffusion体验（本地部署篇）"><a href="#Stable-Diffusion体验（本地部署篇）" class="headerlink" title="Stable Diffusion体验（本地部署篇）"></a>Stable Diffusion体验（本地部署篇）</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>环境：python3.10.6（模型推荐版本）、CUDA、Git</li><li>github仓库：<a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui">https://github.com/AUTOMATIC1111/stable-diffusion-webui</a></li></ul><p>开始部署前如果python版本不是3.10.6建议卸载重装python，因为是stable官方推荐使用版本，不这样的话很容易报错而且是一个接一个（血泪教训）</p><ul><li>步骤： 首先将clone项目到本地，然后进入主文件夹并运行webui-user批处理程序<br>此时会创建一个venv的虚拟运行环境（虚拟环境中的pip与python程序是系统的镜像，所有关于Stable diffusion的依赖都必须使用虚拟环境的python以及pip进行下载，切记使用全局环境的pip下载成无效）<br>安装完成后重新运行webui-user，出现下图时，就可以直接在<a href="http://127.0.0.1:7860/">http://127.0.0.1:7860</a> 访问可视化界面了</li></ul><p>Docker部署请参考：<a href="https://juejin.cn/post/7235083283133530170">https://juejin.cn/post/7235083283133530170</a></p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>首次运行建议科学上网，因为有需要从github下载的模块，当然也可以修改launch.py中的github替换为代理地址<br>如果出现error <code>pip install ...</code>的错误，则需要进入<code>venv/Scripts/</code>使用该文件夹下的python以及pip下载对应插件 <code>F:\\stable-diffusion-webui\venv\Sctipts\python.exe -m pip install ...</code><br>如果出现clip安装失败，需要先将<code>https://github.com/mlfoundations/open_clip</code>复制到本地然后将其放在<code>F:\\stable-diffusion-webui\venv\Sctipts</code>文件夹下，进入文件夹运行<code>F:\\stable-diffusion-webui\venv\Sctipts\python.exe setup.py build install</code>，然后回到主文件夹运行webui-user.bat，如果还是报错则需要使用 <code>F:\\stable-diffusion-webui\venv\Sctipts\python.exe -m pip install open-clip</code>然后运行</p><ul><li>错误处理参考：<a href="https://blog.csdn.net/weixin_40735291/article/details/129333599">https://blog.csdn.net/weixin_40735291/article/details/129333599</a></li></ul><p>开启后如果设置或者加入提示词时报<code>error column 1...</code>的错误则需要关闭代理重启模型<br>请关注详细的报错提示，大多数错误都有提示解决办法，建议耐心看完</p><ul><li><p>注意：使用前必须设置启动参数，不然用以显存爆表</p></li><li><p>自用启动参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line"></span><br><span class="line">set PYTHON=</span><br><span class="line">set GIT=</span><br><span class="line">set VENV_DIR=</span><br><span class="line">set COMMANDLINE_ARGS= --opt-sub-quad-attention --medvram</span><br><span class="line"></span><br><span class="line">call webui.bat</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>非训练方式使用很简单使用默认的模型点击生成后即可等待出图，如果使用模型则需要在<a href="https://civitai.com/">https://civitai.com</a> 安装需要的大模型放在<code>.\models\Stable-diffusion</code>文件夹下，也可以使用其他例如LORA等模型进行生成</p><p>如果遇到问题建议去问chatgpt或者claude，效率应该比直接google高</p><h2 id="关于提示词"><a href="#关于提示词" class="headerlink" title="关于提示词"></a>关于提示词</h2><h3 id="负面提示词"><a href="#负面提示词" class="headerlink" title="负面提示词"></a>负面提示词</h3><ul><li>通用负面提示词: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(deformed iris, deformed pupils, semi-realistic, cgi, 3d, render, sketch, cartoon, drawing, anime:1.4), </span><br><span class="line">text, close up, cropped, out of frame, worst quality, low quality, jpeg artifacts, ugly, duplicate, </span><br><span class="line">morbid, mutilated, extra fingers, mutated hands, poorly drawn hands, poorly drawn face, mutation, </span><br><span class="line">deformed, blurry, dehydrated, bad anatomy, bad proportions, extra limbs, cloned face, disfigured, </span><br><span class="line">gross proportions, malformed limbs, missing arms, missing legs, extra arms, extra legs, fused fingers, </span><br><span class="line">too many fingers, long neck</span><br></pre></td></tr></table></figure></li><li>正面提示词<br>利用chatGPT生成正面提示词的方法，将下面这段描述发给GPT-4即可<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">以下提示用于指导Al绘画模型创建图像。它们包括人物外观、背景、颜色和光影效果，以及图像的主题和风格等各种细节。</span><br><span class="line">这些提示的格式通常包括带权重的数字括号，用于指定某些细节的重要性或强调。</span><br><span class="line">例如，&quot;(masterpiece:1.4)&quot;表示作品的质量非常重要。以下是一些示例： </span><br><span class="line">1.(8k, RAW photo, best quality, masterpiece:1.2),(realistic, photo-realistic:1.37), ultra-detailed, </span><br><span class="line">1girl, cute, solo, beautiful detailed sky, detailed cafe, night, sitting, dating, (nose blush), </span><br><span class="line">(smile:1.1),(closed mouth), medium breasts, beautiful detailed eyes, (collared shirt:1.1), bowtie, </span><br><span class="line">pleated skirt, (short hair:1.2), floating hair, ((masterpiece)), ((best quality)), 2.(masterpiece, </span><br><span class="line">finely detailed beautiful eyes: 1.2), ultra-detailed, illustration, 1 girl, blue hair black hair, </span><br><span class="line">japanese clothes, cherry blossoms, tori, street full of cherry blossoms, detailed background, realistic, </span><br><span class="line">volumetric light, sunbeam, light rays, sky, cloud, 3.highres, highest quallity, illustration, cinematic light, </span><br><span class="line">ultra detailed, detailed face, (detailed eyes, best quality, hyper detailed, masterpiece, (detailed face),</span><br><span class="line">blue hairlwhite hair, purple eyes, highest details, luminous eyes, medium breats, black halo, white clothes, </span><br><span class="line">backlighting, (midriff:1.4), light rays, (high contrast), (colorful). 仿照之前的提示，写一段描写如下要素的提示：车水马龙的城市</span><br></pre></td></tr></table></figure></li><li>通用反向提示词（2）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lowres,bad anatomy,bad hands,text,error,missing fingers,</span><br><span class="line">extra digit,fewer digits,cropped,worst quality,</span><br><span class="line">low quality,normal quality,jpeg artifacts,signature,</span><br><span class="line">watermark,username,blurry,missing arms,long neck,</span><br><span class="line">Humpbacked,missing limb,too many fingers,</span><br><span class="line">mutated,poorly drawn,out of frame,bad hands,</span><br><span class="line">unclear eyes,poorly drawn,cloned face,bad face</span><br></pre></td></tr></table></figure></li></ul><h2 id="汉化"><a href="#汉化" class="headerlink" title="汉化"></a>汉化</h2><ul><li>汉化：<a href="https://github.com/VinsonLaro/stable-diffusion-webui-chinese">https://github.com/VinsonLaro/stable-diffusion-webui-chinese</a></li><li>汉化推荐使用方法2，快速方便，使用webui内部的download可能报错无法下载</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>提示词可视化：<a href="https://moonvy.com/apps/ops/">https://moonvy.com/apps/ops/</a></li><li>模型库：<a href="https://civitai.com/">https://civitai.com/</a>  <a href="https://huggingface.co/models">https://huggingface.co/models</a></li><li>模型资源探索指南：<a href="https://zhuanlan.zhihu.com/p/597504900">https://zhuanlan.zhihu.com/p/597504900</a></li><li>LORA：<a href="https://zhuanlan.zhihu.com/p/600628691">https://zhuanlan.zhihu.com/p/600628691</a></li></ul><h2 id="教学文档参考"><a href="#教学文档参考" class="headerlink" title="教学文档参考"></a>教学文档参考</h2><p><a href="https://www.tjsky.net/tutorial/457#i-3">https://www.tjsky.net/tutorial/457#i-3</a> 很详细的教学，有详细的参数，共4篇建议详细研读</p><h2 id="模型推荐"><a href="#模型推荐" class="headerlink" title="模型推荐"></a>模型推荐</h2><p>人物模型（亚洲审美）：<a href="https://civitai.com/models/6424/chilloutmix">https://civitai.com/models/6424/chilloutmix</a></p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI绘图 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nestjs学习笔记</title>
      <link href="/2023/01/13/Nestjs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/13/Nestjs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Nest学习笔记"><a href="#Nest学习笔记" class="headerlink" title="Nest学习笔记"></a>Nest学习笔记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习Nestjs更多的处于兴趣，公司项目中有使用nest，从代码结构看感觉跟springboot的写法类似，我也在自己的部分demo项目中应用了Nestjs+express作为框架进行开发，因此开始学习Nest的相关知识</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在学习Nestjs之前需要有一定的TypeScript的使用或学习经验，虽然Nest支持使用原生纯js进行书写，但是官方示例以及cli工具生成的代码都是ts的，笔记中的相关代码部分我也会应用ts进行记录。</p><p>支持版本：Node.js(&gt;&#x3D; 10.13.0, v13版本除外)</p><ul><li>版本查看命令如下：</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">v14.<span class="number">17</span>.<span class="number">3</span></span><br><span class="line">$ npm -v</span><br><span class="line">v7.x.x</span><br></pre></td></tr></table></figure><p>注：如果电脑没有node环境，或没有node相关基础请移步<a href="https://www.runoob.com/nodejs/nodejs-tutorial.html">node教程</a></p><ul><li>安装Nest Cli工具及创建项目：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i -g @nestjs/cli</span><br><span class="line">nest new project-name</span><br></pre></td></tr></table></figure><ul><li><p>通过cli创建的项目中包含以下核心文件：<br>src<br> |- app.controller.spec.ts (对于基本控制器的单元测试样例)<br> |- app.controller.ts （带有单个路由的基本控制器示例）<br> |- app.module.ts （应用程序的根模块）<br> |- app.service.ts （带有单个方法的基本服务）<br> |- main.ts （应用程序入口文件。它使用 NestFactory 用来创建 Nest 应用实例）</p></li><li><p>作为渐进式框架兼容express：<br>创建应用时可以直接指定需要使用的HTTP平台</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">await</span> <span class="title class_">NestFactory</span>.<span class="property">create</span>&lt;<span class="title class_">NestExpressApplication</span>&gt;(<span class="title class_">AppModule</span>);</span><br></pre></td></tr></table></figure><ul><li>运行方式<code>npm run start</code></li></ul><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>Controller主要用于通过分组路由对传入的请求进行处理并向客户端返回响应</p><h3 id="创建与路由"><a href="#创建与路由" class="headerlink" title="创建与路由"></a>创建与路由</h3><blockquote><p>cli快捷命令：<code>nest g controller project-name</code></p></blockquote><p>注解<code>@Controller()</code>中存在可选参数路由前缀，可以通过设置路由前缀对文件中的路由进行分组，例如<code>@Controller(index)</code>必须通过<code>localhost:3000/index</code>来请求，这样就不需要在内部方法中重指定路由前缀了，官方示例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* cats.controller.ts */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Controller</span>, <span class="title class_">Get</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span>(<span class="string">&#x27;cats&#x27;</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">CatsController</span> &#123;</span><br><span class="line">  <span class="meta">@Get</span>()</span><br><span class="line">  <span class="title function_">findAll</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;This action returns all cats&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>路由路径：用于指定请求的处理方法，可以通过<code>/路由前缀/装饰器路由信息</code>的方式生成路由映射</p><p>装饰器：即<code>@Get()</code>、<code>@Post()</code>等在内的HTTP请求方法装饰器，用于指定端点对应的HTTP请求方法</p></blockquote><p>路由中支持使用通配符<code>*</code>用于匹配任何字符组合即字符 <code>?</code> 、<code>+</code> 、 <code>*</code> 以及 <code>()</code> 是它们的正则表达式对应项的子集。连字符<code>-</code> 和点<code>.</code>按字符串路径逐字解析。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Get</span>(<span class="string">&#x27;ab*cd&#x27;</span>)</span><br><span class="line"><span class="title function_">findAll</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;This route uses a wildcard&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述路由可以匹配<code>abcd</code>、<code>ab_cd</code>、<code>abecd</code>等</p><h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><p>Nest在提供了一些方案来处理请求细节，它提供了对于请求对象(request)的访问方式，可以通过处理函数中的<code>@Req()</code>装饰器，指示Nest将请求对象注入处理程序，当然在正常的程序书写中，我们也不会直接去处理整个request对象相反我们更多的是处理<code>HTTP header</code>和<code>Http body</code>的属性，因此Nest也提供了<code>@Body</code>和<code>@Query</code>等可以开箱即用的装饰器<br>详细对照请参考()[<a href="https://docs.nestjs.cn/9/controllers]">https://docs.nestjs.cn/9/controllers]</a></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span>(<span class="string">&#x27;index&#x27;</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AppController</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> <span class="keyword">readonly</span> appService: AppService</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Get</span>(<span class="string">&#x27;getHello&#x27;</span>)</span><br><span class="line">  <span class="title function_">getHello</span>(<span class="meta">@Req</span>() <span class="attr">req</span>: <span class="title class_">Request</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;req: &#x27;</span>, req);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;helo&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求中我们总会处理各种状态码，可以通过在处理函数外添加<code>@HttpCode()</code>注解指定需要的状态码<br>我们可以使用<code>@Header()</code>来指定自定义的响应头</p><p>如果在一些特定情况下需要将响应重定向到指定的<code>URL</code>（例如404的时候），可以使用<code>@Redirect()</code>制定需要的<code>URL</code><br><code>@Redirect()</code>中有两个可选参数，一个就是<code>url</code>，另一个是<code>statusCode</code>，如果省略第二个参数则会默认使用<code>302</code>状态码</p><p>当我们在请求处理中需要接收<strong>动态数据</strong>的时候<code>@Param</code>可以通过下述两种方式进行获取所需的路由参数，访问方法为<code>GET /cats/1</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Get</span>(<span class="string">&#x27;:id&#x27;</span>)</span><br><span class="line"><span class="title function_">findOne</span>(<span class="meta">@Param</span>() params): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(params.<span class="property">id</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`This action returns a #<span class="subst">$&#123;params.id&#125;</span> cat`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Get</span>(<span class="string">&#x27;:id&#x27;</span>)</span><br><span class="line"><span class="title function_">findOne</span>(<span class="meta">@Param</span>(<span class="string">&#x27;id&#x27;</span>) id): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`This action returns a #<span class="subst">$&#123;id&#125;</span> cat`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步数据"><a href="#异步数据" class="headerlink" title="异步数据"></a>异步数据</h3><p>每一个异步函数都必须返回一个<code>Promise</code>，因此Nest支持使用异步函数(<code>Async / await</code>)，Nest会自动解析这个被返回的<code>Promise</code>值</p><h3 id="请求负载"><a href="#请求负载" class="headerlink" title="请求负载"></a>请求负载</h3><p>在<code>POST</code>请求中我们可以使用<code>@Body()</code>获取请求传入的参数，如果应用<code>Typescript</code>则需要确定<code>DTO</code>（数据传输对象），它定义了需要数据的格式，可以通过ts的<code>interface</code>或<code>class</code>来定义<code>DTO</code>模式，Nest更推荐使用<code>class</code>来定义</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  create-demo.dto.ts</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">CreateDemoDto</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">breed</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过定义可以直接在下述<code>DemoController</code>中通过不同的两种方式使用创建的<code>DTO</code>:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* demo.controller.ts */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Post</span>()</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">create</span>(<span class="params"><span class="meta">@Body</span>() createDemoDto: CreateDemoDto</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;This action adds a new demo&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Post</span>()</span><br><span class="line"><span class="meta">@Bind</span>(<span class="title class_">Body</span>())</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">create</span>(<span class="params">createCatDto</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;This action adds a new demo&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册控制器"><a href="#注册控制器" class="headerlink" title="注册控制器"></a>注册控制器</h3><p>当Controller已经准备就绪后，我们需要告知Nest该Controller的存在，而Controller总是属于Module的，所以我们可以看到<code>@Module()</code>装饰器中包含了<code>controllers</code>数组</p><p>因此可以通过以下方式进行定义：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* app.module.ts */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Module</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">DemoController</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./demos/demo.controller&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  <span class="attr">controllers</span>: [<span class="title class_">DemoController</span>],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AppModule</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="Provide"><a href="#Provide" class="headerlink" title="Provide"></a>Provide</h2><blockquote><p>CLI快捷命令：<code>$ nest g service cats</code></p></blockquote><p><code>Provide</code>是一个使用<code>@Injectble()</code>装饰器注释的类，它的设计理念源于控制反转(IOC)中依赖注入的特性</p><p>Nest 的分层借鉴自 Spring，更细化。随着代码库的增长 MVC 模式中 Modal 和 Controller 会变得含糊不清，导致难于维护。</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>先从一个服务开始了解<code>Provide</code>，先创建一个简单的负责数据存储与检索的服务<code>DemoService</code>开始</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  cats.service.ts  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Injectable</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Cat</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./interfaces/cat.interface&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">CatsService</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="attr">cats</span>: <span class="title class_">Cat</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="title function_">create</span>(<span class="params">cat: Cat</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cats</span>.<span class="title function_">push</span>(cat);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">findAll</span>(): <span class="title class_">Cat</span>[] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">cats</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* cats.controller.ts */</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Controller</span>, <span class="title class_">Get</span>, <span class="title class_">Post</span>, <span class="title class_">Body</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CreateCatDto</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./dto/create-cat.dto&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CatsService</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats.service&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Cat</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./interfaces/cat.interface&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span>(<span class="string">&#x27;cats&#x27;</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">CatsController</span> &#123;</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> catsService: CatsService</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Post</span>()</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">create</span>(<span class="params"><span class="meta">@Body</span>() createCatDto: CreateCatDto</span>) &#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">catsService</span>.<span class="title function_">create</span>(createCatDto);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Get</span>()</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">findAll</span>(): <span class="title class_">Promise</span>&lt;<span class="title class_">Cat</span>[]&gt; &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">catsService</span>.<span class="title function_">findAll</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CatsService</code> 是通过类构造函数注入的。注意这里使用了私有的只读语法。这意味着我们已经在同一位置创建并初始化了 <code>catsService</code> 成员。</p><p>上面示例中<code>constructor(private catsService: CatsService) &#123;&#125;</code>就是依赖注入的一种体现，<br><code>Nest</code>将<code>catsService</code>创建后会返回一个实例来解析<code>CatsService</code></p><p>Provider通常拥有与主体程序同步的生命周期，即作用域</p><p>在<code>constructor</code>的参数中可以使用<code>@Optional()</code>标明参数可选</p><p>对于依赖注入不仅仅只有上述通过构造函数注入的方式，但是如果一个顶级类需要依赖于一个或多个<code>providers</code>时这种方式就会变得很麻烦，因此这时我们可以使用基于属性的注入，即应用<code>@Inject()</code>装饰器</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Injectable</span>, <span class="title class_">Inject</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">HttpService</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="meta">@Inject</span>(<span class="string">&#x27;HTTP_OPTIONS&#x27;</span>)</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="attr">httpClient</span>: T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果您的类没有扩展其他提供者，你应该总是使用基于构造函数的注入。</p></blockquote><p>当我们在<code>controller</code>中注册了服务的使用者以后，我们需要在<code>Nest</code>中注册这个服务，以便于其可以正确地执行注入</p><p>我们可以编辑模块文件<code>app.module.ts</code>，然后将服务添加到<code>@Module()</code>装饰器的<code>providers</code>数组中。</p><h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><blockquote><p>CLI快捷命令：<code>$ nest g module cats</code></p></blockquote><p>Module是一个具有<code>@Module</code>装饰器的类，Nest通过Module形成了整体的应用程序结构</p><p>每一个Nest程序至少有一个Module，被称为<font color="red">根模块</font>，当应用程序比较小的时候它就应该是唯一的模块</p><p><code>@Module()</code>装饰器可以接收一个描述模块属性的对象：</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Module</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CatsController</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats.controller&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CatsService</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats.service&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  <span class="attr">controllers</span>: [<span class="title class_">CatsController</span>], <span class="comment">// 必须创建的一组控制器</span></span><br><span class="line">  <span class="attr">providers</span>: [<span class="title class_">CatsService</span>], <span class="comment">// 由Nest注入实例化的提供者</span></span><br><span class="line">  <span class="attr">imports</span>: [<span class="title class_">CommonModule</span>], <span class="comment">// 导入模块的列表，这些模块导出了此模块中所需provider</span></span><br><span class="line">  <span class="attr">exports</span>: [<span class="title class_">CatsService</span>] <span class="comment">// 由本模块提供并可以在其他模块中应用的的providers</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">CatsModule</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>当我们将子模块导出后可以直接在根模块<code>ApplicationModule</code>中进行导入</p><p>实际上每个模块都是一个<strong>共享模块</strong>，一旦创建就能被任意的模块重复使用，当我们需要在几个模块之间共享一个<code>Service</code>实例，那么我们只需要将该<code>Service</code>放到<code>exports</code>数组中即可<br>之后每个导入此<code>Module</code>的模块都可以直接访问该&#96;Service</p><p><code>provider</code>可以通过依赖注入写入<code>Module</code>中但是不能反过来将<code>Module</code>注入<code>provider</code></p><h3 id="全局模块"><a href="#全局模块" class="headerlink" title="全局模块"></a>全局模块</h3><p>有些模块可能由于一些原因需要封装一些公用的东西（例如数据库连接、helper等），那这个时候讲究需要用到全局模块</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Module</span>, <span class="title class_">Global</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CatsController</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats.controller&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CatsService</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats.service&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Global</span>()</span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  <span class="attr">controllers</span>: [<span class="title class_">CatsController</span>],</span><br><span class="line">  <span class="attr">providers</span>: [<span class="title class_">CatsService</span>],</span><br><span class="line">  <span class="attr">exports</span>: [<span class="title class_">CatsService</span>],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">CatsModule</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>@Global</code>装饰器可以使模块编程全局作用于，而全局模块只需要在核心模块中注册一次，如此则不需要再在其他需要使用该全局模块的地方再次引入了</p><h3 id="动态模块"><a href="#动态模块" class="headerlink" title="动态模块"></a>动态模块</h3><p>动态模块是<code>Nest</code>中的一个强大功能，这些模块可以动态注册和配置提供程序，下面是官方提供的一个动态模块<code>DatabaseModule</code>的定义示例：</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Module</span>, <span class="title class_">DynamicModule</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createDatabaseProviders &#125; <span class="keyword">from</span> <span class="string">&#x27;./database.providers&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Connection</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./connection.provider&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  <span class="attr">providers</span>: [<span class="title class_">Connection</span>],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">DatabaseModule</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">forRoot</span>(entities = [], options?): <span class="title class_">DynamicModule</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> providers = <span class="title function_">createDatabaseProviders</span>(options, entities);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">module</span>: <span class="title class_">DatabaseModule</span>,</span><br><span class="line">      <span class="attr">providers</span>: providers,</span><br><span class="line">      <span class="attr">exports</span>: providers,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Module</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createDatabaseProviders &#125; <span class="keyword">from</span> <span class="string">&#x27;./database.providers&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Connection</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./connection.provider&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line"> <span class="attr">providers</span>: [<span class="title class_">Connection</span>],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">DatabaseModule</span> &#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="title function_">forRoot</span>(<span class="params">entities = [], options?</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> providers = <span class="title function_">createDatabaseProviders</span>(options, entities);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">   <span class="attr">module</span>: <span class="title class_">DatabaseModule</span>,</span><br><span class="line">   <span class="attr">providers</span>: providers,</span><br><span class="line">   <span class="attr">exports</span>: providers,</span><br><span class="line">  &#125;;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>forRoot函数可以返回一个动态模块，这个模块可以使同步的也可以是异步的</p></blockquote><p>上述方式通过默认的方式封装了一个<code>Connection</code>的<code>provider</code>，此外还通过将一个包含<code>entities</code>和<code>options</code>的对象传入<code>forRoot()</code>方法中（类似一个存储库）<br>动态模块返回的属性扩展（非覆盖方式）了通过<code>@Module</code>装饰器定义的基础模块的元数据，这就是通过模块导出静态声明的<code>Connection</code>提供程序和动态生成的存储库<code>provider</code>的方式</p><p>如果需要再全局范围内注册动态模块则需要将上述<code>return</code>中的<code>global</code>属性设置为<code>true</code></p><p>对于上述<code>DatabaseModule</code>可以被导入，导入方式如下：</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Module</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">DatabaseModule</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./database/database.module&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">User</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./users/entities/user.entity&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [<span class="title class_">DatabaseModule</span>.<span class="title function_">forRoot</span>([<span class="title class_">User</span>])],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AppModule</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>如果需要重新导出动态模块则可以省略<code>forRoot</code>方法调用</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Module</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">DatabaseModule</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./database/database.module&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">User</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./users/entities/user.entity&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [<span class="title class_">DatabaseModule</span>.<span class="title function_">forRoot</span>([<span class="title class_">User</span>])],</span><br><span class="line">  <span class="attr">exports</span>: [<span class="title class_">DatabaseModule</span>],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AppModule</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="中间件（Middleware）"><a href="#中间件（Middleware）" class="headerlink" title="中间件（Middleware）"></a>中间件（Middleware）</h2><p>中间件是一个在路由跳转之前调用的函数，这个函数可以访问<code>request</code>和<code>response</code>对象，以及应用程序的请求响应周期中的<code>next()</code>中间件函数</p><p>这里的中间件实际上与<code>Express</code>中的中间件相同</p><blockquote><p>中间件函数可以执行如下任务：</p><ul><li>执行任何代码</li><li>对<code>request/response</code>对象进行修改</li><li>结束请求&#x2F;响应周期</li><li>调用堆栈中的下一个中间件函数</li><li>如果在这个中间件函数中没有对请求&#x2F;响应周期进行终止则需要调用<code>next()</code>方法传递到下一个中间件函数，否则这个请求&#x2F;响应将被挂起</li></ul></blockquote><p>定义一个中间件函数应该在其具有<code>@Injectable()</code>装饰器的类中实习<code>NestMiddleware</code>接口，如果是一个函数则没有特殊要求</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Injectable</span>, <span class="title class_">NestMiddleware</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Request</span>, <span class="title class_">Response</span>, <span class="title class_">NextFunction</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">LoggerMiddleware</span> <span class="keyword">implements</span> <span class="title class_">NestMiddleware</span> &#123;</span><br><span class="line">  <span class="title function_">use</span>(<span class="params">req: Request, res: Response, next: NextFunction</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request...&#x27;</span>);</span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>中间件同样支持依赖注入</p></blockquote><h3 id="应用中间件"><a href="#应用中间件" class="headerlink" title="应用中间件"></a>应用中间件</h3><p>中间件不能在<code>@Module</code>中列出，我们必须使用模块类的<code>configure()</code>方法来进行设置，且必须实现<code>NestModule</code>接口</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Module</span>, <span class="title class_">NestModule</span>, <span class="title class_">MiddlewareConsumer</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">LoggerMiddleware</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./common/middleware/logger.middleware&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CatsModule</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats/cats.module&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [<span class="title class_">CatsModule</span>],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AppModule</span> <span class="keyword">implements</span> <span class="title class_">NestModule</span> &#123;</span><br><span class="line">  <span class="title function_">configure</span>(<span class="params">consumer: MiddlewareConsumer</span>) &#123;</span><br><span class="line">    consumer</span><br><span class="line">      .<span class="title function_">apply</span>(<span class="title class_">LoggerMiddleware</span>)</span><br><span class="line">      .<span class="title function_">forRoutes</span>(<span class="string">&#x27;cats&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们对中间件进行配置时可以将包含路径的对象和请求方法传入<code>forRoutes()</code>方法，这样可以进一步地将中间件限制为特定的请求方法</p><p>如下导入<code>RequestMethod</code>来引用所有需要的请求方法类型</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Module</span>, <span class="title class_">NestModule</span>, <span class="title class_">RequestMethod</span>, <span class="title class_">MiddlewareConsumer</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">LoggerMiddleware</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./common/middleware/logger.middleware&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CatsModule</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats/cats.module&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line"> <span class="attr">imports</span>: [<span class="title class_">CatsModule</span>],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AppModule</span> <span class="keyword">implements</span> <span class="title class_">NestModule</span> &#123;</span><br><span class="line">    <span class="title function_">configure</span>(<span class="params">consumer: MiddlewareConsumer</span>) &#123;</span><br><span class="line">        consumer</span><br><span class="line">          .<span class="title function_">apply</span>(<span class="title class_">LoggerMiddleware</span>)</span><br><span class="line">          .<span class="title function_">forRoutes</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;cats&#x27;</span>, <span class="attr">method</span>: <span class="title class_">RequestMethod</span>.<span class="property">GET</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路由通配符"><a href="#路由通配符" class="headerlink" title="路由通配符"></a>路由通配符</h3><p>在中间件的路由匹配中支持模式匹配，通配符的使用和正则类似，例如<code>*</code>可以匹配任意字符，例如下方示例：</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">forRoutes</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;ab*cd&#x27;</span>, <span class="attr">method</span>: <span class="title class_">RequestMethod</span>.<span class="property">ALL</span> &#125;);</span><br></pre></td></tr></table></figure><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p><code>forRoutes()</code>不仅仅可以接收字符串、对象还能接收一个甚至多个控制类，大多数情况下都会传入一个控制器列表</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Module</span>, <span class="title class_">NestModule</span>, <span class="title class_">MiddlewareConsumer</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">LoggerMiddleware</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./common/middleware/logger.middleware&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CatsModule</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats/cats.module&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CatsController</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats/cats.controller.ts&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [<span class="title class_">CatsModule</span>],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AppModule</span> <span class="keyword">implements</span> <span class="title class_">NestModule</span> &#123;</span><br><span class="line">  <span class="title function_">configure</span>(<span class="params">consumer: MiddlewareConsumer</span>) &#123;</span><br><span class="line">    consumer</span><br><span class="line">      .<span class="title function_">apply</span>(<span class="title class_">LoggerMiddleware</span>)</span><br><span class="line">      .<span class="title function_">forRoutes</span>(<span class="title class_">CatsController</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在应用中间件中想要排除一些路由可以使用<code>exclude()</code>方法进行操作，这个方法参数可以是一个字符串、多个字符串或者一个<code>RouterInfo</code>对象</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">consumer</span><br><span class="line">  .<span class="title function_">apply</span>(<span class="title class_">LoggerMiddleware</span>)</span><br><span class="line">  .<span class="title function_">excude</span>(</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;cats&#x27;</span>, <span class="attr">method</span>: <span class="title class_">RequestMethod</span>.<span class="property">GET</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;cats&#x27;</span>, <span class="attr">method</span>: <span class="title class_">RequestMethod</span>.<span class="property">POST</span> &#125;,</span><br><span class="line">    <span class="string">&#x27;cats/(.*)&#x27;</span>,</span><br><span class="line">  )</span><br><span class="line">  .<span class="title function_">forRoutes</span>(<span class="title class_">CatsController</span>);</span><br></pre></td></tr></table></figure><h3 id="函数中间件"><a href="#函数中间件" class="headerlink" title="函数中间件"></a>函数中间件</h3><p>从上面的介绍中可以知道<code>LoggerMiddleware</code>类非常简单，实际上他可以只使用一个简单的函数而这种类型我们称为函数式中间件</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">logger</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Request...`</span>);</span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义后可以直接在<code>appModule</code>中进行使用</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.<span class="title function_">apply</span>(logger).<span class="title function_">forRoutes</span>(<span class="title class_">CatsController</span>);</span><br></pre></td></tr></table></figure><p>上面我们也提到了可以同时引入多个中间件，方法如下</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.<span class="title function_">apply</span>(<span class="title function_">cors</span>(), <span class="title function_">helmet</span>(), logger).<span class="title function_">forRoutes</span>(<span class="title class_">CatsController</span>);</span><br></pre></td></tr></table></figure><h3 id="全局中间件"><a href="#全局中间件" class="headerlink" title="全局中间件"></a>全局中间件</h3><p>我们可以使用<code>INestApplication</code>实例中提供的<code>use()</code>方法直接将中间件绑定到所有的已注册路由</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">NestFactory</span>&#125; <span class="keyword">from</span> <span class="string">&quot;@nestjs/core&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">AppModule</span>&#125; <span class="keyword">from</span> <span class="string">&quot;./app.module&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">await</span> <span class="title class_">NestFactory</span>.<span class="title function_">create</span>(<span class="title class_">AppModule</span>);</span><br><span class="line">app.<span class="title function_">use</span>(logger);</span><br><span class="line"><span class="keyword">await</span> app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><h2 id="异常过滤器"><a href="#异常过滤器" class="headerlink" title="异常过滤器"></a>异常过滤器</h2><p>Nest中提供了内置的异常层，开箱即用，这个异常处理操作由内置的全局异常过滤器负责，该过滤器可以处理<code>HttpException</code>的异常，如果异常无法被识别时，用户将收到如下&#96;JSON</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"> <span class="attr">&quot;statusCode&quot;</span><span class="punctuation">:</span> <span class="number">500</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Internal server error&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="基础异常"><a href="#基础异常" class="headerlink" title="基础异常"></a>基础异常</h3><p><code>Nest</code>中有一个内置的<code>HttpException</code>类，最常用的就是在发生错误时发送标准的HTTP响应对象</p><p>在如下示例中会模拟一个异常</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Get</span>()</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">findall</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HttpException</span>(<span class="string">&#x27;Forbidden&#x27;</span>, <span class="title class_">HttpStatus</span>.<span class="property">FORBIDDEN</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当触发请求时客户端就会收到如下响应</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;statusCode&quot;</span><span class="punctuation">:</span> <span class="number">403</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Forbidden&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><code>HttpException</code>构造函数有两个必要参数：</p><ul><li><code>response</code>参数是一个<code>JSON</code>响应体</li><li><code>status</code>定义<code>HTTP</code>状态码</li></ul><p><code>JSON</code>响应体包含两个属性：</p><ul><li><code>statusCode</code>：状态码</li><li><code>message</code>：基于状态的错误描述</li></ul><p>一般情况下我们不需要编写自定义异常，如果确实需要创建自定义异常则要创建自己的异常层次结构</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Get</span>&#125; <span class="keyword">from</span> <span class="string">&quot;@nestjs/common&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ForbiddenException</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HttpException</span> &#123;</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">super</span>(<span class="string">&#x27;Forbidden&#x27;</span>, <span class="title class_">HttpStatus</span>.<span class="property">FORBIDDEN</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以像下面这样使用上述自定义异常</span></span><br><span class="line"><span class="meta">@Get</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">findAll</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ForbiddenException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常过滤器-1"><a href="#异常过滤器-1" class="headerlink" title="异常过滤器"></a>异常过滤器</h3><p>异常过滤器可以赋予开发者对于异常层完全控制权</p><p>异常过滤器可以用来捕获作为<code>HttpException</code>类实例的异常并设置自定义的响应逻辑，因此我们需要应用<code>Request</code>和<code>Response</code>对象来进行我们想要的操作</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ExceptionFilter</span>, <span class="title class_">Catch</span>, <span class="title class_">ArgumentsHost</span>, <span class="title class_">HttpException</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Request</span>, <span class="title class_">Response</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Catch</span>(<span class="title class_">HttpException</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">HttpExceptionFilter</span> <span class="keyword">implements</span> <span class="title class_">ExceptionFilter</span> &#123;</span><br><span class="line">    <span class="keyword">catch</span>(<span class="attr">exception</span>: <span class="title class_">HttpException</span>, <span class="attr">host</span>: <span class="title class_">ArgumentsHost</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> ctx = host.<span class="title function_">switchToHttp</span>();</span><br><span class="line">        <span class="keyword">const</span> response = ctx.<span class="property">getResponse</span>&lt;<span class="title class_">Response</span>&gt;();</span><br><span class="line">        <span class="keyword">const</span> request = ctx.<span class="property">getRequest</span>&lt;<span class="title class_">Request</span>&gt;();</span><br><span class="line">        <span class="keyword">const</span> status = exception.<span class="title function_">getStatus</span>();</span><br><span class="line">        </span><br><span class="line">        response.<span class="title function_">status</span>(status).<span class="title function_">json</span>(&#123;</span><br><span class="line">         <span class="attr">statusCode</span>: status,</span><br><span class="line">         <span class="attr">timestamp</span>: <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toISOString</span>(),</span><br><span class="line">         <span class="attr">path</span>: request.<span class="property">url</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>所有的异常过滤器都必须实现通用的<code>ExceptionFilter&lt;T&gt;</code>接口</p></blockquote><p>在过滤器编写完成后需要将过滤器绑定到<code>controller</code>的<code>create()</code>方法上</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="meta">@Post</span>()</span><br><span class="line"><span class="meta">@UseFilters</span>(<span class="keyword">new</span> <span class="title class_">HttpExceptionFilter</span>())</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">create</span>(<span class="params"><span class="meta">@Body</span>() createCatDto: CreateCatDto</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ForbiddenException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="meta">@Post</span>()</span><br><span class="line"><span class="meta">@UseFilters</span>(<span class="title class_">HttpExceptionFilter</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">create</span>(<span class="params"><span class="meta">@Body</span>() createCatDto: CreateCatDto</span>) &#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ForbiddenException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述两种在实际使用时更推荐使用类而非使用实例，这样可以减少对内存的占用</p><p>异常过滤器的作用域可以划分为三个级别：方法范围、控制器范围以及全局范围</p><p>方法范围和控制器范围都是在相关方法或<code>Controller</code>上配置<code>@UseFilters()</code>，而全局范围的配置可以如下使用：</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">NestFactory</span>&#125; <span class="keyword">from</span> <span class="string">&quot;@nestjs/core&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">bootstrap</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">const</span> app = <span class="keyword">await</span> <span class="title class_">NestFactory</span>.<span class="title function_">create</span>(<span class="title class_">AppModule</span>);</span><br><span class="line"> app.<span class="title function_">userGlobalFilters</span>(<span class="keyword">new</span> <span class="title class_">HttpExceptionFilter</span>());</span><br><span class="line"> <span class="keyword">await</span> app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">bootstrap</span>();</span><br></pre></td></tr></table></figure><p>通过上述<code>useGlobalFilters()</code>方法配置时不会为网关和混合应用程序设置过滤器</p><p>下面这种办法可以注册一个全局范围的过滤器</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Module</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@nestjs/common&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">APP_FILTER</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/core&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line"> <span class="attr">providers</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">provide</span>: <span class="variable constant_">APP_FILTER</span>,</span><br><span class="line">    <span class="attr">useClass</span>: <span class="title class_">HttpExceptionFilter</span></span><br><span class="line">  &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AppModule</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>在编写异常过滤器时使用<code>@Catch()</code>装饰器列表为空则默认捕获每一个未处理的异常</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>通常我们将创建完全定制化的异常过滤器，如果想要重用一个已经实现了核心逻辑的异常过滤器，并重写部分方法，那么就需要用到继承</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Catch</span>, <span class="title class_">ArgumentsHost</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BaseExceptionFilter</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/core&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Catch</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AllExceptionsFilter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">BaseExceptionFilter</span> &#123;</span><br><span class="line">    <span class="keyword">catch</span>(<span class="attr">exception</span>: <span class="built_in">unknown</span>, <span class="attr">host</span>: <span class="title class_">ArgimetsHost</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>.<span class="title function_">catch</span>(exception, host);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pipes（管道）"><a href="#Pipes（管道）" class="headerlink" title="Pipes（管道）"></a>Pipes（管道）</h2><p><code>Pipes</code>是具有<code>@Injectable()</code>装饰器的类，<code>Pipes</code>应该实现<code>PipeTransform</code>接口。</p><p>通常<code>pipes</code>会处理来自控制器路由处理程序的参数，Nest会在调用这个方法之前插入一个管道，管道会先拦截方法的调用参数，进行预处理</p><p>Nest中有很多开箱即用的内置管道，下面会有将内置<code>pipes</code>绑定在<code>controller</code>上的示例</p><blockquote><p>当管道内抛出异常时controller将不会继续执行</p></blockquote><h3 id="内置管道"><a href="#内置管道" class="headerlink" title="内置管道"></a>内置管道</h3><p>Nest中一共有九个开箱即用的管道：</p><ul><li>ValidationPipe</li><li>ParseIntPipe</li><li>ParseFloatPipe</li><li>ParseBoolPipe</li><li>ParseArrayPipe</li><li>ParseUUIDPipe</li><li>ParseEnumPipe</li><li>DefaultValuePipe</li><li>ParseFilePipe</li></ul><p>以上的几个管道都是从<code>@nestjs/common</code>包中导出的</p><p>下面将通过<code>ParseIntPage</code>来演示一下转换的应用场景</p><h3 id="绑定管道"><a href="#绑定管道" class="headerlink" title="绑定管道"></a>绑定管道</h3><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Get</span>(<span class="string">&#x27;:id&#x27;</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">findOne</span>(<span class="params"><span class="meta">@Param</span>(<span class="string">&#x27;id&#x27;</span>, ParseIntPipe) id: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">catsService</span>.<span class="title function_">findOne</span>(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能确保<code>findOne()</code>方法所接受的参数是一个数字，且在路由处理程序呗调用之前就被处理并抛出异常</p><p><code>GET localhost:3000/abc</code><br>这样请求后Nest就会放回相关异常</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;statusCode&quot;</span><span class="punctuation">:</span> <span class="number">400</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Validation failed (numeric string is expected)&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Bad Request&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>异常抛出后<code>findOne</code>方法不会被继续执行，上述方法中我们传入的是一个类将实例化的部分交给框架进行处理也就是依赖注入，我们也可以选择传入一个实例</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Get</span>(<span class="string">&#x27;:id&#x27;</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">findOne</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="meta">@Param</span>(<span class="string">&#x27;id&#x27;</span>, <span class="keyword">new</span> ParsseIntPipe(&#123; errorHttpStatusCode: HttpStatus.NOT_ACCEPTABLE &#125;))</span></span><br><span class="line"><span class="params">    id: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">catService</span>.<span class="title function_">findOne</span>(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同上述操作一样，其他的<code>Parse*</code>管道的使用方式一致</p></blockquote><h3 id="自定义管道"><a href="#自定义管道" class="headerlink" title="自定义管道"></a>自定义管道</h3><p>如上文说的Nest提供了很多强大的内置管道，但是有些清关我们也需要使用更加定制化的管道</p><p>以一个自定义的简单<code>ValidationPipe</code>为例：</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">PipeTranform</span>, <span class="title class_">Injectable</span>, <span class="title class_">ArgumentMetadata</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ValidationPipe</span> <span class="keyword">implements</span> <span class="title class_">PipeTranform</span> &#123;</span><br><span class="line">    <span class="title function_">transform</span>(<span class="params">value: <span class="built_in">any</span>, metadata: ArgumentMetadata</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>PipeTransform&lt;T, R&gt;</code>是管道必须实现的泛型接口，T是value类型，R是<code>transform()</code>方法的返回类型</p></blockquote><p><code>transform</code>方法有两个参数<code>value</code>和<code>metadata</code>,<code>value</code>事当前处理的方法的参数，<code>metadata</code>是当前处理的方法参数的元数据</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">ArgumentMetadata</span> &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;body&#x27;</span> | <span class="string">&#x27;query&#x27;</span> | <span class="string">&#x27;param&#x27;</span> | <span class="string">&#x27;custom&#x27;</span>;</span><br><span class="line">  metatype?: <span class="title class_">Type</span>&lt;<span class="built_in">unknown</span>&gt;;</span><br><span class="line">  data?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>type</code>：参数是一个body<code>@Body()</code>，query<code>@Query()</code>，param<code>@Param()</code>或其他自定义参数</li><li><code>metatype</code>: 数据元类型，如<code>String</code>等</li><li><code>data</code>传递给装饰器的字符串，例如<code>@Body(&#39;string&#39;)</code></li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><code>Pipes</code>有两个典型的应用场景：</p><ul><li>转换：将输入数据转换为需要的数据输出</li><li>验证：对输入的数据进行验证，如果验证成功则继续传递，否则抛出异常</li></ul><h2 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h2><ul><li><a href="https://keelii.com/2019/07/04/nestjs-framework-tutorial-1">《Nestjs 框架教程》</a></li><li><a href="https://docs.nestjs.cn/9/controllers">《Nestjs 中文文档》</a></li><li><a href="https://nestjs.bootcss.com/">《Nestjs 中文网》</a></li><li><a href="https://juejin.cn/post/7069426618724253704">《nest+MangoDB部署服务器》</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
            <tag> Node </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue学习笔记 — Vue的响应式原理</title>
      <link href="/2022/12/22/vue3.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/12/22/vue3.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue3-0学习笔记"><a href="#Vue3-0学习笔记" class="headerlink" title="Vue3.0学习笔记"></a>Vue3.0学习笔记</h1><p>Vue3.0的学习正在一点点地推进，我会在这里记录一些学习的过程与重要的知识点</p><p>该笔记仅记录componsitionApi的方式</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>～～</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>组件是vue中最重要的内容之一，组件内部也有很多区别于基础的方法与属性</p><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><ol><li><p>当我们需要将一个对象的所有属性全部当作prop传入的时候，可以使用v-bind的方式直接传入整个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// post对象中所有的属性都要单独传入</span></span><br><span class="line"><span class="keyword">const</span> post = &#123;</span><br><span class="line">   <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">   <span class="attr">title</span>: <span class="string">&#x27;Hello Word&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该情况下下面的两种使用方式完全相同</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">BlogPost</span> <span class="attr">v-bind</span>=<span class="string">&quot;post&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BlogPost</span> <span class="attr">:id</span>=<span class="string">&quot;post.id&quot;</span> <span class="attr">:title</span>=<span class="string">&quot;post.title&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>⚠️ 通过prop传入的对象&#x2F;数组都是通过引用的形式，因此在自组件中修改对应的对象&#x2F;数组内部的值并不会报错且会修改原值</p></li><li><p>所有的prop参数默认为可选的，如果需要必选则要声明<code>require: true</code></p></li><li><p>由于对ts的支持，prop的type也可以是自定义的类或构造函数，可以通过<code>instanceof</code>来检查、断言</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="title function_">constructor</span>(<span class="params">firstName, lastName</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">firstName</span> = firstName</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">lastName</span> = lastName</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">defineProps</span>(&#123;</span><br><span class="line">   <span class="attr">author</span>: <span class="title class_">Persion</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如上会校验<code>author</code>的值是否是通过<code>new Person</code>的方式创建的</p></li></ol><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><ol><li><p>组件内事件的声明可以通过<code>const emit = defineEmits([&#39;inFocus&#39;, &#39;submit&#39;])</code>的方式进行声明</p></li><li><p><code>emits</code>方法支持对象语法，可以用来对触发事件的参数进行验证</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">const</span> emit = <span class="title function_">defineEmits</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">submit</span>: <span class="function">(<span class="params">&#123;account, password&#125;</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">         <span class="keyword">if</span> (account &amp;&amp; password) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">         &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;账号/密码未通过校验&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">         &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">   &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>虽是可选的但是官方推荐将所有要出发的emit事件都定义到emits中</p></li></ol><h3 id="属性透传"><a href="#属性透传" class="headerlink" title="属性透传"></a>属性透传</h3><p>当我们在父元素中对子组件挂在了一个属性或者v-on监听事件，那么当dom渲染时会将这些属性透传到子组件的根元素中，并与根元素已有的属性活事件进行合并，最常见的就是<code>class</code>和<code>style</code>的设定</p><p>如果我们不希望组件自动继承透传属性则需要在组件选项中设置<code>inheritAttrs: false</code><br>如果使用的是<code>&lt;script setup&gt;</code>方式则需要增加一个<code>&lt;script&gt;</code>来书写这个声明</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">inheritAttrs</span>: <span class="literal">false</span></span></span><br><span class="line"><span class="language-javascript">   &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">// ...setup 部分逻辑</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如此设定之后可以通过<code>v-bind=“$attrs”</code>来决定透传进来的属性如何应用</p><p>在js中可以通过<code>const attrs = useAttrs()</code>的方式访问一个组件的所有透传attribute（非响应式）</p><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><p>插槽是组件只是中最重要的一个属性，也是自定义组件中最重要的一部分</p><p>⚠️插槽内容是无法访问子组件数据的</p><ul><li>任何父组件模板中的东西都只被编译到父组件的作用域中；而任何子组件模板中的东西都只被编译到子组件的作用域中。</li><li>子组件的模板中的内容只能通过插槽来访问，不能通过子组件的data来访问</li></ul><p>当我们在父组件中使用子组件中定义的具名插槽时，可以使用<code>v-slot:name</code>的指令，也可简写为<code>#name</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">BaseLayout</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">BaseLayout</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 此处两种方式作用相同 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BaseLayout</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">template</span> #<span class="attr">header</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">BaseLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>作用域插槽：在某些场景下我们需要我们可能需要同时使用父组件域内和子组件域内的数据（例如<code>&lt;el-table&gt;</code>组件中的自定义列），这样的情况就需要使用作用域插槽来实现</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:text</span>=<span class="string">&quot;message&quot;</span> <span class="attr">:count</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 父组件1 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">v-slot</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">   &#123;&#123; slotProps.text &#125;&#125; &#123;&#123; slotProps.count &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 父组件2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123;text, count&#125;&quot;</span>&gt;</span></span><br><span class="line">   &#123;&#123; text &#125;&#125; &#123;&#123; count &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></span><br></pre></td></tr></table></figure><p> <img src="https://staging-cn.vuejs.org/assets/scoped-slots.1c6d5876.svg" alt="图1"></p></li></ul><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p><strong>背景</strong>：当我们需要从父组件向子组件传递数据时我们会使用props进行传递，但是在真实开发中存在组件层层嵌套，层级很深的情况，在层层嵌套传递数据的过程中，会有很多组件其实并不关心这个props但是迫于子组件需要又必须沿着链路传递下去，这一过程被称为“prop drilling”，这时候我们就需要使用依赖注入的方式来解决这个问题</p><p>解决这个问题我们可以使用<code>provide</code>和<code>inject</code>来实现，<code>provide</code>用来提供依赖，<code>inject</code>用来注入依赖，无论层级多深都可以注入由父组件提供给这条链路的依赖</p><ul><li><p>Provide：用来提供依赖，可以提供多个依赖，也可以提供一个依赖</p><ul><li>如果我们不使用<code>&lt;script setup&gt;</code>的方式，那么必须保证<code>provide</code>与<code>setup()</code>可以同步调用</li></ul> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; provide &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">provide</span>(<span class="comment">/* 注入名 */</span> <span class="string">&#x27;message&#x27;</span>, <span class="comment">/* 值 */</span> <span class="string">&#x27;hello!&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Inject：用来注入依赖，可以注入多个依赖，也可以注入一个依赖</p><ul><li>如果注入的值是一个ref，则不会进行解包，保持响应性链接</li><li>如果我们不使用<code>&lt;script setup&gt;</code>的方式，那么必须保证<code>inject</code>与<code>setup()</code>可以同步调用</li><li><code>inject(key, value)</code>如果该key值没有被任何处于组件链中的组件提供，则value为其默认值（形似props）</li></ul></li><li><p>在我们注入一个响应式的值的时候，我们应该尽量保证对响应式状态的修改都保持在<code>provide</code>内部，这样可以确保provide的状态和变更操作都位于同一个组件内部</p></li><li><p>如果某些情况下我们需要在injector中更改数据，那么可以在provide中提供一个函数，这个函数会在injector中被调用，这样就可以在injector中修改数据</p></li><li><p>如果想要保证通过provide传的数据无法被injector修改，那么可以使用<code>readonly</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">import</span> &#123; provide, inject, readonly &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span></span><br><span class="line"><span class="language-javascript">   <span class="title function_">provide</span>(<span class="string">&#x27;count&#x27;</span>, <span class="title function_">readonly</span>(count));</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>协同开发中推荐使用Symbol来作为注入名来避免命名冲突</p></li></ul><h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><p>Vue中提供了一个<code>defineAsyncComponent</code>方法用于在需要时再从服务器加载相关组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AsyncComp</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">/*从服务器加载组件*/</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">         <span class="title function_">resolve</span>(&#123;</span><br><span class="line">            <span class="comment">/* 获取到的组件 */</span></span><br><span class="line">            <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>defineAsyncComponent</code>方法接收的是一个返回Promise的函数，这个函数会在组件被调用时执行，这个函数返回的Promise会在组件被渲染时被解析，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import#%E5%8A%A8%E6%80%81%E5%AF%BC%E5%85%A5ES">模块动态导入</a>也会返回一个Promise，所以可以和<code>defineAsyncComponent</code>配合使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AsyncComp</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="title function_">import</span>(<span class="comment">/* webpackChunkName: &#x27;async-comp&#x27; */</span> <span class="string">&#x27;./async-comp.vue&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上述程序的执行可以得到一个<code>AsyncComp</code>的包装器组件，这个包装器组件会在组件被渲染时被解析，并且会在组件被渲染时被解析，这样就可以在组件被渲染时加载相关的组件</p><p>当然异步操作一定会涉及到加载和错误状态的处理，因此<code>defineAsyncComponent()</code>也支持处理这些状态</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">AsyncComp</span> = <span class="title function_">defineAsyncComponent</span>(&#123;</span><br><span class="line">  <span class="comment">// 加载函数</span></span><br><span class="line">  <span class="attr">loader</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;./Foo.vue&#x27;</span>),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载异步组件时使用的组件</span></span><br><span class="line">  <span class="attr">loadingComponent</span>: <span class="title class_">LoadingComponent</span>,</span><br><span class="line">  <span class="comment">// 展示加载组件前的延迟时间，默认为 200ms</span></span><br><span class="line">  <span class="attr">delay</span>: <span class="number">200</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载失败后展示的组件</span></span><br><span class="line">  <span class="attr">errorComponent</span>: <span class="title class_">ErrorComponent</span>,</span><br><span class="line">  <span class="comment">// 如果提供了一个 timeout 时间限制，并超时了</span></span><br><span class="line">  <span class="comment">// 也会显示这里配置的报错组件，默认值是：Infinity</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">3000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><p>先看一个例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 在模板中启用 v-focus</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> vFocus = &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">mounted</span>: <span class="function">(<span class="params">el</span>) =&gt;</span> el.<span class="title function_">focus</span>()</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-focus</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码执行的效果就是会在页面加载时自动聚焦到input，而<code>focue</code>就是我们自定义的指令，这会比<code>autofocus</code>更有用，因为它可以在任何你需要的时候运行</p><p>所谓自定义指令的目的就是为了重用涉及到元素底层DOM访问的逻辑。</p><p>自定义指令在模版中使用前必须提前进行注册，即使用<code>directives</code>选项完成注册，在<code>&lt;script setup&gt;</code>中任何以<code>v</code>开头的驼峰式命名的变量都可以被用作自定义指令，即<code>vFocus</code>在模版中可以<code>v-focus</code>的方式使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">directives</span>: &#123;</span><br><span class="line">    <span class="comment">// 在模板中启用 v-focus</span></span><br><span class="line">    <span class="attr">focus</span>: &#123;</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以通过以下方法将自定义指令注册在全局</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使 v-focus 在所有组件中都可用</span></span><br><span class="line">app.<span class="title function_">directive</span>(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="指令钩子"><a href="#指令钩子" class="headerlink" title="指令钩子"></a>指令钩子</h3><p>一个指令的定义对象可以有如下钩子可供选择：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myDirective = &#123;</span><br><span class="line">  <span class="comment">// 在绑定元素的 attribute 前</span></span><br><span class="line">  <span class="comment">// 或事件监听器应用前调用</span></span><br><span class="line">  <span class="title function_">created</span>(<span class="params">el, binding, vnode, prevVnode</span>) &#123;</span><br><span class="line">    <span class="comment">// 下面会介绍各个参数的细节</span></span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 在元素被插入到 DOM 前调用</span></span><br><span class="line">  <span class="title function_">beforeMount</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="comment">// 在绑定元素的父组件</span></span><br><span class="line">  <span class="comment">// 及他自己的所有子节点都挂载完成后调用</span></span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="comment">// 绑定元素的父组件更新前调用</span></span><br><span class="line">  <span class="title function_">beforeUpdate</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="comment">// 在绑定元素的父组件</span></span><br><span class="line">  <span class="comment">// 及他自己的所有子节点都更新后调用</span></span><br><span class="line">  <span class="title function_">updated</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="comment">// 绑定元素的父组件卸载前调用</span></span><br><span class="line">  <span class="title function_">beforeUnmount</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="comment">// 绑定元素的父组件卸载后调用</span></span><br><span class="line">  <span class="title function_">unmounted</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>钩子参数如下：</p><ul><li><code>el</code>：指令绑定到的元素。这可以用于直接操作 DOM</li><li><code>binding</code>：一个对象，包含以下 property。<br><code>value</code>：传递给指令的值<br><code>oldValue</code>：之前的值，仅在 beforeUpdate 和 updated 中可用。无论值是否更改，它都可用<br><code>arg</code>：传递给指令的参数<br><code>modifiers</code>：一个包含修饰符的对象<br><code>instance</code>：使用该指令的组件实例<br><code>dir</code>：指令的定义对象</li><li><code>vnode</code>：代表绑定元素的底层VNode</li><li><code>prevNode</code>：之前的渲染中代表指令所绑定元素的 VNode。仅在 <code>beforeUpdate</code> 和 <code>updated</code> 钩子中可用。</li></ul><h3 id="简化形式"><a href="#简化形式" class="headerlink" title="简化形式"></a>简化形式</h3><p>如果在自定义指令中需要在<code>mounted</code>和<code>updated</code>上实现相同的行为，且无需定义在其他钩子中的事件时，可以进行如下操作</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-color</span>=<span class="string">&quot;color&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   app.<span class="title function_">directive</span>(<span class="string">&#x27;color&#x27;</span>, <span class="function">(<span class="params">el, binding</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 这会在 `mounted` 和 `updated` 时都调用</span></span></span><br><span class="line"><span class="language-javascript">      el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span></span></span><br><span class="line"><span class="language-javascript">   &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="内置组件"><a href="#内置组件" class="headerlink" title="内置组件"></a>内置组件</h2><h3 id="Teleport·传送门"><a href="#Teleport·传送门" class="headerlink" title="Teleport·传送门"></a>Teleport·传送门</h3><p><code>&lt;Teleport&gt;</code> 是一个内置组件，使我们可以将一个组件的一部分模板“传送”到该组件的 DOM 层次结构之外的 DOM 节点中。</p><p><code>&lt;Teleport&gt;</code> 最好的实例就是模态框的实现，<code>&lt;Teleport :to=&quot;body&quot;&gt;</code>可以将标签下的元素传送到body上，它只会改变渲染的DOM结构，并不会改变</p>]]></content>
      
      
      <categories>
          
          <category> Vue学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3.0的新特性</title>
      <link href="/2022/12/21/Vue3.0%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2022/12/21/Vue3.0%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue3-0的新特性"><a href="#Vue3-0的新特性" class="headerlink" title="Vue3.0的新特性"></a>Vue3.0的新特性</h1><h2 id="源码管理方式"><a href="#源码管理方式" class="headerlink" title="源码管理方式"></a>源码管理方式</h2><p>相对于Vue2.x中源码的组织方式，Vue3.0使用了<code>monorepo</code>，它将这些模块拆分到不同的package中，每一个package都有它对应的API、类型定义和测试</p><p>这样将模块拆分的更加细化，模块更加独立、模块之间的依赖关系也更加明确，开发人员更容易阅读、理解和更改所有块源码，增加了代码的可维护性</p><h2 id="开发语言支持"><a href="#开发语言支持" class="headerlink" title="开发语言支持"></a>开发语言支持</h2><p>Vue2.x使用的是原生JavaScript语言开发，因此对ts的支持并不是很好，在Vue3.0中，完全支持了TypeScript语言，使开发变得更加面向对象，增加了类型检查</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>Vue3.0在代码体积减小方面做了以下优化</p><ul><li>移除了一些冷门的feature</li><li>引入了tree-shaking技术</li></ul><p><strong>tree-shaking:</strong> 依赖ES2015模块语法的静态结构（import和export），通过编译阶段的静态分析，找到没有引入的模块并打上标记，如果在项目中没有引入<code>Transition</code>、<code>KeepAlive</code>等组件，那么他们对应的代码就不会被打包，这样就间接达到了减少项目引入的Vue.js包体积的目的</p><h2 id="数据劫持优化"><a href="#数据劫持优化" class="headerlink" title="数据劫持优化"></a>数据劫持优化</h2><p>数据的响应式与双向绑定，一直以来都是Vue最大的优点之一</p><p>在Vue1.x和2.x中都是通过<code>Object.definePrototype</code>这个API对数据的<code>getter</code>和<code>setter</code>进行劫持</p><p>但是这种方法一直存在着缺点，那就是无法检测数据的添加与删除，因此Vue添加了$set和$delete的方法</p><p>为了解决这些问题，Vue3.0中使用了Proxy API进行数据劫持，Proxy API并不能监听到内部深层次的对象变化</p><p>因此Vue3.0的解决方法是在getter内部进行递归响应式</p><h2 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h2><p>new Vue() &#x3D;&gt; init &#x3D;&gt; $mount &#x3D;&gt; compile &#x3D;&gt; render &#x3D;&gt; vnode &#x3D;&gt; patch &#x3D;&gt; DOM</p><p>Vue2.x的版本中，如果需要对有数据绑定的节点进行更新，使用diff算法是需要对所有动静态节点进行遍历，而理想状态是直接更新绑定了数据的节点</p><p>Vue3.0通过编译阶段对节点进行分析，编译生成了Block tree（将模板基于动态节点指令切割的嵌套区块，每个区块的内部节点结构是固定的，每个区块只需要一个Array来追踪自身包含的动态节点）</p><p>Vue3.0还在编译阶段还进行了对slot的编译优化、事件侦听函数的缓存优化，并且在运行时重写了diff算法</p><h2 id="语法API优化：-Composition-API"><a href="#语法API优化：-Composition-API" class="headerlink" title="语法API优化： Composition API"></a>语法API优化： Composition API</h2><p>这里需要分两点来说</p><h3 id="优化逻辑组织"><a href="#优化逻辑组织" class="headerlink" title="优化逻辑组织"></a>优化逻辑组织</h3><p>在Vue2.x中，编写组件的本质就是编写一个“包含了描述组件选项的对象”，它被成为Options API（按照methods, computed、data、props）这些不同的选项进行分类</p><p>组件小的时候，这种分类方式一目了然，但是大型组件中会有多个逻辑关注点，当使用Options API时，每一个关注点都有自己的Options</p><p>如果需要修改一个逻辑关注点，就需要在单个文件中进行上下切换和寻找</p><p>Vue3.0中提供了一种新的API就是Composition API，它会将某个逻辑关注点的相关代码都放在一个函数中，这样我们需要修改一个功能时就不用在文件中跳来跳去了</p><p>下面是两种写法的直观对比</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--  vue2 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      a: 1</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    b() &#123;</span><br><span class="line">      return a + 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    c: &#123;</span><br><span class="line">      type: Object,</span><br><span class="line">      default() &#123;</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    m1() &#123;</span><br><span class="line">      return &#x27;m1&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- vue3 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div &gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&#x27;ts&#x27; setup&gt;</span><br><span class="line">import &#123; ref, onMounted &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const props = defineProps(&#123;</span><br><span class="line">  b: [String, Number],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const a = ref(&#123;&#125;);</span><br><span class="line">onMounted(async () =&gt; &#123;</span><br><span class="line">  init();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const init = () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;init&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&#x27;less&#x27; scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="优化逻辑复用"><a href="#优化逻辑复用" class="headerlink" title="优化逻辑复用"></a>优化逻辑复用</h3><p>Vue2.x中我们会使用mixins进行混入复用，但是缺点也很明显，就是每个mixins都会定义自己的props、data这样就很容易导致变量冲突</p><p>对组件而言如果模板中使用不在当前组件中定义的变量，就不太容易知道这些变量是在哪里定义的（数据来源不清晰）</p><p>Vue3.0中使用Composition API，就很好地解决了mixins的这两个问题</p><h2 id="引入RFC：使每个版本改动可控"><a href="#引入RFC：使每个版本改动可控" class="headerlink" title="引入RFC：使每个版本改动可控"></a>引入RFC：使每个版本改动可控</h2><p>RFC(Request For Comments)为新功能进入框架提供一个一致且受控的路径</p><p>在Vue3.0中大规模启用了RFC，可以了解每一个feature采用或被废弃掉的前因后果</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是Vue3.0相对于Vue2.x的最新特性，最为技术发展的主流方向，Vue3.0虽然距离完全普及应用还有很可观的一段时间，而我们更早地学习Vue3.0的相关知识，就更能提升自己，更能掌握未来技术发展的大方向。</p>]]></content>
      
      
      <categories>
          
          <category> Vue学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue3 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>版本控制-Git的学习与应用</title>
      <link href="/2022/12/16/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-Git%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
      <url>/2022/12/16/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-Git%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="版本控制-Git的学习与应用"><a href="#版本控制-Git的学习与应用" class="headerlink" title="版本控制-Git的学习与应用"></a>版本控制-Git的学习与应用</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。</p><p>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p><p>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。</p><p>通俗一点来说就是一个用于控制代码存储仓库以及进行协同开发的工具，同类型的版本控制工具还有cvs、Subversion等</p><p>常用的远程库：github、gitee以及gitlab，其实还有阿里仓库、腾讯云仓库等</p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ol><li>克隆 Git 资源作为工作目录</li><li>在克隆的资源上添加或修改文件。</li><li>如果其他人修改了，你可以更新资源。</li><li>在提交前查看修改。</li><li>提交修改。</li><li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</li></ol><p><img src="https://www.runoob.com/wp-content/uploads/2015/02/git-process.png"></p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>Git会将每一次提交的所有文件保存为一个快照，如果这次提交的文件没有修改，那么git就会只保留一个链接指向之前存储的文件。</p><p>Git几乎不会执行任何可能导致文件不可恢复的操作。</p><h2 id="Git-工作区、暂存区和版本库"><a href="#Git-工作区、暂存区和版本库" class="headerlink" title="Git 工作区、暂存区和版本库"></a>Git 工作区、暂存区和版本库</h2><ul><li><strong>工作区：</strong>就是你在电脑里能看到的目录。</li><li><strong>暂存区：</strong>英文叫 stage 或 index。一般存放在 <strong>.git</strong> 目录下的 index 文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）</li><li><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库。</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2015/02/1352126739_7909.jpg"></p><p>左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage&#x2F;index），标记为 “master” 的是 master 分支所代表的目录树，HEAD是一个指针</p><p>objects 标识的区域为 Git 的对象库，实际位于 “.git&#x2F;objects” 目录下，里面包含了创建的各种对象及内容。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>1、这个命令可以将git能找到的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><p>2、初始化git仓库，这条命令会创建一个名为.git的子目录，这里面含有初始化git的所有必须文件，可以为仓库创建.gitignore文件，避免一些无用文件的提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>3、查看文件处于什么状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>4、命令使用文件或目录的路径作为参数将文件存入暂存区，如果参数是当前目录，则将递归地跟踪该目录下的所有文件，如果运行命令后又对已经跟踪的文件进行了修改那么一定要重新运行git add这条命令，否则所提交的文件就会是之前运行命令时的状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;project-name / .&gt;</span><br></pre></td></tr></table></figure><p>5、不加入参数调用git diff命令，可以查看尚未暂存的文件更新了哪些部分（与已暂存的版本对比而不是已经提交的版本对比），想要查看已经暂存起来的变化，可以添加–cache</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cache</span><br></pre></td></tr></table></figure><p>6、可以通过git commit命令将已经暂存的文件进行提交，在提交前应该运行git status查看是否有已修改但未暂存的文件保存在本地，提交后git会 告诉你当前是哪个分支，本次提交的完整校验和，以及本次提交有多少文件被修订过（提交的是放在暂存区域的快照），这样可以将暂存区的所有内容提交到当前分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &#x27;备注说明&#x27;</span><br></pre></td></tr></table></figure><p>7、git checkout – ***可以撤销修改，使文件回到最近一次提交的状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;project-name&gt;</span><br></pre></td></tr></table></figure><p>8、git push 命令可以将当前分支推送到远程指定分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p>9、<strong>危险操作：</strong>git remote rm ***可以删除远程指定库</p><p>10、git clone命令可以克隆一个与远程仓库一样的本地库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;url&gt;</span><br></pre></td></tr></table></figure><p>11、在仓库建立的时候会提供一个master分支，而这个分支会指向最新的提交点，而HEAD指向master也就间接指向了最新提交，我们可以新建分支，并将修改提交到新的分支上，这时分支之间就会出现差距，而HEAD可以通过改变指向不同的分支 来查看不同的版本</p><p>12、我们可以通过git checkout -b ***来创建一个新分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;new-branch-name&gt;</span><br></pre></td></tr></table></figure><p>13、通过git branch可以查看当前仓库所拥有的分支，以及现在HEAD指向的分支，然后通过git checkout ***来切换分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch git checkout &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p>14、git merge ***可以将指定的分支合并到当前分支上，这样HEAD与当前分支都会指向最新的版本，这个命令会包含所有分支的所有提交</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/WluiacE1ZzJrEJibHibPm7b0QEF1l5IcuLc5KZfWkORnJRESka2N3Zf0Mffe0gfic3Fas6Uk426HbnBtOun1JibRYOA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p>15、当我们不同的分支中都对同一个进行了不同的修改，这样在合并的时候就会出现冲突，Git会提示我们哪些文件存在冲突，Git会在文件中用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支下不同的内容，我们做出修改后可以再进行提交。</p><p>16、git pull与git push相反，可以从远程仓库拉取指定分支内容到本地</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p>17、建立本地分支与远程分支的关联</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream &lt;branch-name&gt; &lt;origin/branch-name&gt;git branch --set-upstream-to=origin/&lt;branch-name&gt; &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p>18、git rebase可以将push的分叉历史整理成直线，直接上图，与上面的merge对比更直观</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/WluiacE1ZzJrEJibHibPm7b0QEF1l5IcuLc7osp4cvABwW4M4VJeL2WmDPGib7qCKyEyA7Pia9etrb8cUzBCiaIWa9jw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>19、Git可以打标签，使用git tag可以查看已有的标签，Git一共有两种标签：轻量标签与附注标签，轻量标签就像一个永远不会改变的分支，附注标签是一个存储在Git数据库中的完整对象，命令附加-d代表删除，标签同样可以通过git push origin &lt;tag-name &#x2F; –tags&gt;的方法推送到远程</p><p>附注标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a &lt;tag-name&gt; -m &quot;标签信息&quot;    </span><br></pre></td></tr></table></figure><p>轻量标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;tag-name / commit id&gt;</span><br></pre></td></tr></table></figure><h2 id="学习网站"><a href="#学习网站" class="headerlink" title="学习网站"></a>学习网站</h2><p><a href="https://learngitbranching.js.org/?locale=zh_CN">https://learngitbranching.js.org/?locale=zh_CN</a></p><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰git教程</a></p><h2 id="工具推荐"><a href="#工具推荐" class="headerlink" title="工具推荐"></a>工具推荐</h2><ol><li><a href="https://www.sourcetreeapp.com/">sourceTree</a></li><li><a href="https://git-fork.com/">Fork</a></li><li>WebStorm内部git插件</li><li><a href="https://my.oschina.net/wzzz/blog/179598">vscode插件</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 联合开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flex布局</title>
      <link href="/2020/12/09/Flex%E5%B8%83%E5%B1%80/"/>
      <url>/2020/12/09/Flex%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h1><p>我们熟知的css布局有以下几种：绝对定位、相对定位、表格布局、响应式布局、浮动布局、弹性盒布局</p><p>下面我就搬运一下阮一峰老师的弹性盒布局（Flex）的基础属性与用法</p><h2 id="传统布局"><a href="#传统布局" class="headerlink" title="传统布局"></a>传统布局</h2><p>布局的传统解决方案是使用盒模型，依赖display属性+position属性+float属性，但是这种布局方式就会出现狠不容易实现垂直居中的状况，而现在有了flex布局，对于响应式与简易实现布局提供了更多的可能</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote><p>flex布局，意为弹性布局，可以为盒模型提供更加灵活的布局方式</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-flex; // 行内元素的弹性布局</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用Webkit内核的浏览器，必须加上<code>-webkit-</code>前缀</p><p><font color="red">设置为flex布局以后，<code>float</code>、<code>clear</code>、<code>vertical-aligin</code>等属性都会失效。</font></p><p>Flex容器默认存在两个轴：水平主轴与垂直交叉轴。项目默认沿主轴排列。</p><h2 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h2><p>共有6个属性设置在容器之上：</p><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul><h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"><span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    row: 主轴为水平方向</span></span><br><span class="line"><span class="comment">    row-reverse: 主轴为水平反方向</span></span><br><span class="line"><span class="comment">    column: 主轴为垂直方向</span></span><br><span class="line"><span class="comment">    column-reverse: 主轴为垂直反方向</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png"></p><h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p>默认情况下，项目都排列在一条线上。如果一条直线排不下就需要使用此属性进行换行</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    nowrap：不换行</span></span><br><span class="line"><span class="comment">    wrap：换行</span></span><br><span class="line"><span class="comment">    wrap-reverse：换行，第一行在下方</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><p><code>flex-flow</code>是<code>flex-direction</code>和<code>flex-wrap</code>的简写方式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>:  || ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p><code>justify-content</code>是主轴上的对称方式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    flex-start: 左对齐</span></span><br><span class="line"><span class="comment">    flex-end: 右对齐</span></span><br><span class="line"><span class="comment">    center: 居中</span></span><br><span class="line"><span class="comment">    space-between: 两端对齐，项目之间间隔相等</span></span><br><span class="line"><span class="comment">    space-around: 每个项目之间间隔相等，项目之间的间隔比项目与边框的间隔大一倍</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png"></p><h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    flex-start: 交叉轴起点对齐</span></span><br><span class="line"><span class="comment">    flex-end: 交叉轴终点对齐</span></span><br><span class="line"><span class="comment">    center: 交叉轴居中对齐</span></span><br><span class="line"><span class="comment">    baseline: 项目第一行文字的基线对齐</span></span><br><span class="line"><span class="comment">    stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png"></p><h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><p><code>align-content</code>定义了多条轴线的对齐方式，如果轴线只有一条则不起作用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    flex-start：与交叉轴的起点对齐。</span></span><br><span class="line"><span class="comment">    flex-end：与交叉轴的终点对齐。</span></span><br><span class="line"><span class="comment">    center：与交叉轴的中点对齐。</span></span><br><span class="line"><span class="comment">    space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</span></span><br><span class="line"><span class="comment">    space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</span></span><br><span class="line"><span class="comment">    stretch（默认值）：轴线占满整个交叉轴。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h2><p>有6个属性设置在项目上</p><ul><li>order</li><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li><li>flex</li><li>align-self</li></ul><h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><p><code>flex-grow</code>定义项目的放大比例，默认为0</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: ; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><p><code>flex-shrink</code>定义了项目的缩小比例，默认为1，即空间不足时项目会缩小</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: ; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>:  | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间。</p><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p>flex属性是<code>flex-grow</code>、<code>flex-shrink</code>和<code>flex-basis</code>的简写，默认<code>0 1 auto</code>。后两个属性可选。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt;<span class="string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="string">&#x27;flex-basis&#x27;</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该属性有两个快捷值：<code>auto (1 1 auto)</code> 和 <code>none (0 0 auto)</code>。</p><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>]]></content>
      
      
      <categories>
          
          <category> Css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css </tag>
            
            <tag> 前端 </tag>
            
            <tag> Flex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React学习笔记 - 基础篇</title>
      <link href="/2020/11/22/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20-%20%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
      <url>/2020/11/22/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20-%20%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="React学习笔记-基础篇"><a href="#React学习笔记-基础篇" class="headerlink" title="React学习笔记 - 基础篇"></a>React学习笔记 - 基础篇</h1><p>首先声明在这里看到的很多内容都是官方文档中提到的，当然也加入了一些自己的总结</p><p>在react中一切都是js，我们使用jsx来渲染组件<br>React在渲染所有输入内容之前默认会进行转义，可以有效地防止XSS（cross-site-scripting, 跨站脚本）攻击。</p><h2 id="JSX表示对象"><a href="#JSX表示对象" class="headerlink" title="JSX表示对象"></a>JSX表示对象</h2><p>Babel会将JSX转义成一个名为<code>React.createElement()</code>函数调用。</p><p>以下写法相等：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;greeting&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Hello, World!</span></span><br><span class="line"><span class="language-xml">    h1&gt;</span></span><br><span class="line"><span class="language-xml">);</span></span><br><span class="line"><span class="language-xml">const element = React.createElement(</span></span><br><span class="line"><span class="language-xml">    &#x27;h1&#x27;,</span></span><br><span class="line"><span class="language-xml">    &#123;className: &#x27;greeting&#x27;&#125;,</span></span><br><span class="line"><span class="language-xml">    &#x27;Hello, world!&#x27;</span></span><br><span class="line"><span class="language-xml">)</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//React.createElement()会预先执行一些检查，以帮助你编写无错代码，实际上 创建了一个这样的对象：</span></span><br><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line"><span class="attr">type</span>: <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line"><span class="attr">className</span>: <span class="string">&#x27;greeting&#x27;</span>,</span><br><span class="line"><span class="attr">children</span>: <span class="string">&#x27;Hello, world!&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这些对象被称为 “React 元素”。它们描述了你希望在屏幕上看到的内容。React 通过读取这些对象，然后使用它们来构建 DOM 以及保持随时更新</p><p>所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。</p><h2 id="State-与-生命周期"><a href="#State-与-生命周期" class="headerlink" title="State 与 生命周期"></a>State 与 生命周期</h2><p>对于State我们应该正确的使用setState({})对State的数据进行更新</p><h3 id="我们不能直接修改State"><a href="#我们不能直接修改State" class="headerlink" title="我们不能直接修改State"></a>我们不能直接修改State</h3><p>错误：<code>this.state.comment = &#39;Hello&#39;;</code><br>正确：<code>this.setState(&#123;comment: &#39;Hello&#39;&#125;);</code></p><p>构造函数是唯一一个可以给State直接赋值的地方，在其他地方直接修改的时候不会更新dom</p><h3 id="State-的更新可能是异步的"><a href="#State-的更新可能是异步的" class="headerlink" title="State 的更新可能是异步的"></a>State 的更新可能是异步的</h3><p>出于性能考虑，React 可能会把多个 setState() 调用合并成一个调用<br>由于this.props和this.state可能会异步更新，所以不可以依赖他们的值来更新状态<br>解决上述问题的办法是将setState()的参数设置为一个函数，而不是一个对象，这个函数用上一个state作为第一个参数，将被应用的props作为第二个 参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">state, props</span>) =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">counter</span>: state.<span class="property">counter</span> + props.<span class="property">increment</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h3 id="State-的更新会被合并"><a href="#State-的更新会被合并" class="headerlink" title="State 的更新会被合并"></a>State 的更新会被合并</h3><p>当你调用 setState() 的时候，React 会把你提供的对象合并到当前的 state。</p><h3 id="数据是向下传递的（自上而下、单向）"><a href="#数据是向下传递的（自上而下、单向）" class="headerlink" title="数据是向下传递的（自上而下、单向）"></a>数据是向下传递的（自上而下、单向）</h3><p>组件可以将state作为props向下传递到它的子组件中</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><code>componentDidMount()</code>方法会在组件已经被渲染到 DOM 中后运行</p><h4 id="完整生命周期"><a href="#完整生命周期" class="headerlink" title="完整生命周期:"></a>完整生命周期:</h4><ul><li>卸载挂载过程：<ul><li><code>constructor()</code></li><li><code>componentWillMount()</code></li><li><code>componentDidMount()</code></li><li><code>componentWillUnmount()</code></li></ul></li><li>更新过程：<ul><li><code>componentWillReceiveProps(nexrProps)</code></li><li><code>shouldComponentUpdate(nextProps, nextState)</code></li><li><code>componentWillUpdate(nextProps, nextState)</code></li><li><code>componentDidUpdate(prevProps, prevState)</code></li><li><code>render()</code></li></ul></li><li>React新增生命周期（替代上述两个周期函数）：<ul><li><code>getDerivedStateFromProps(nextProps, prevState)</code></li><li><code>getSnapshotBeforeUpdate(prevProps, prevState)</code></li></ul></li></ul><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>React中事件处理与DOM中的区别：</p><p>React事件的命名方式采用小驼峰，而不是纯小写</p><p>使用JSX语法的时候需要传入一个函数进行处理，而不是传入一个字符串</p><p>在React中不允许使用返回false的方式阻止默认行为，可以显式地使用preventDefault, 例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DOM：</span></span><br><span class="line">&lt;a href=<span class="string">&quot;#&quot;</span> onclick=<span class="string">&quot;console.log(&#x27;The link was clicked.&#x27;); return false&quot;</span>&gt;</span><br><span class="line">    <span class="title class_">Click</span> me</span><br><span class="line">&lt;/a&gt;</span><br><span class="line"><span class="comment">//React：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ActionLink</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params">e</span>) &#123;</span><br><span class="line">        e.<span class="title function_">preventDefault</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;The link was clicked.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            Click me</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在javaScript中class不会默认绑定this，如果不进行手动绑定，那么当在handleClick中使用this时，this为undefined<br>手动绑定方法：</p><ol><li><code>function.bind(this, arguments)</code></li><li><code>(e) =&gt; this.function(arguments, e)</code></li></ol><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><p>在React中使用条件判断时可以使用if语句或者三目运算进行判定<br>可以使用 条件&amp;&amp;视图 的方式进行条件判断<br>当需要进行条件隐藏时，可以在render中返回一个null，组件就会隐藏， return null;时不会对元素进行渲染，且并不会影响生命周期</p><h2 id="列表与key"><a href="#列表与key" class="headerlink" title="列表与key"></a>列表与key</h2><ol><li><p>渲染多个组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> listItems = numbers.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &lt;li&gt;&#123;item&#125;li&gt;)</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;listItems&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>封装成基础列表组件</p><ul><li>使用这种方式时要给每一个列表元素分配一个key，key 在兄弟节点之间必须唯一</li><li>key帮助React识别哪些元素改变了，迫不得已没有唯一值时可以使用索引index当作key</li></ul></li></ol><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><h3 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h3><p>在HTML中表单一般都是自己维护自己的state。并且根据用户的输入进行更新，但是在React中可变状态（mutable state）都存储在state中，并且只能通过使用setState()进行更新。</p><p>我们可以把上述两种结合起来，让React的state成为唯一的数据源，这样就可以在React的组件中对用户输入过程中表单发生的操作进行控制，被React这样控制的组件叫做受控组件</p><ul><li>可以对输入组件的value与React的state值进行绑定，对组件的onChange事件进行绑定，对表单的onSubmit事件进行绑定</li><li>文件的input标签，由于value值是只读的，所以<code>&lt;input type=&quot;file&quot;&gt;</code>是一个非受控组件</li><li>当需要处理多个 input 元素时，我们可以给每个元素添加 name 属性，并让处理函数根据 <code>event.target.name</code> 的值选择要执行的操作。<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里使用了 ES6 计算属性名称的语法更新给定输入名称对应的 state 值</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">    [name]: value</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>在受控组件上指定 value 的 prop 会阻止用户更改输入。如果你指定了 value，但输入仍可编辑，则可能是你意外地将value 设置为 undefined 或 null。</li></ul><p>当然其实React官方也提供了更方便的非受控组件方式，，在之后的学习中也会逐步跟进。</p><h4 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h4><p>状态提升在官方文档中给出的定义是：当多个组件需要反应相同的变化数据时，我们可以将共享状态提升到最近的共同父组件中去</p><p>在官方文档提供的华氏度与摄氏度即时转换的示例中，将子组件中input的value值与父组件传过来的props中的值进行绑定，在input的onChange事件中绑定了父组件的温度转换事件，将所有的值都传输给父组件，由父组件中定义的转换函数转换后，绑定在state的值中，随后再将值传输给父组件，实现了状态提升</p><p>我在这里说的可能有些复杂，具体示例可以查看<a href="https://react.docschina.org/docs/lifting-state-up.html">官方文档</a> ，<font style="color:red;">下文中会有内嵌的官方文档连接</font></p><p>在React的应用中，任何的数据都应该只有一个相对应的”唯一数据源“</p><h2 id="组合与继承"><a href="#组合与继承" class="headerlink" title="组合与继承"></a>组合与继承</h2><ul><li><strong>包含关系:</strong><ul><li>this.props.children可以用来获取放入标签的dom元素，然后直接将这些元素引入到render中，等同于Vue中的slot插槽</li></ul></li><li><strong>特例关系:</strong><ul><li>以Dialog为例，我们可以手动封装一个Dialog组件，将title与message都封装成组件属性，通过传入属性的方式进行组合复用。</li></ul></li></ul><h2 id="React哲学"><a href="#React哲学" class="headerlink" title="React哲学"></a>React哲学</h2><p>建议查看官方描述<a href="https://react.docschina.org/docs/thinking-in-react.html">React哲学</a></p><p>个人感觉很有帮助，会提升代码的规范意识，对编写架构都很有帮助。</p><iframe src="https://react.docschina.org/docs/thinking-in-react.html" height="600" width="100%"></iframe><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用了两周时间第一次学完了React.js的基础知识。</p><p>在学习完第一遍React的基础知识以后我深刻体会到了为什么React现在依然会是很多大厂的首选语言，从生态上来说的确时Vue需要用时间来填补的，但是Vue对比React在有些方面例如插槽、数据传输等方面要更加简便易操作，各有千秋，各有好坏，对于React我的认知还很少，还会更多的了解学习FaceBook对React的发展方向，以及了解最新的技术模式，后续也会跟进更新相关笔记</p>]]></content>
      
      
      <categories>
          
          <category> React学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节跳动-商业变现前端秋招一面</title>
      <link href="/2020/11/22/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8-%E5%95%86%E4%B8%9A%E5%8F%98%E7%8E%B0%E5%89%8D%E7%AB%AF%E7%A7%8B%E6%8B%9B%E4%B8%80%E9%9D%A2/"/>
      <url>/2020/11/22/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8-%E5%95%86%E4%B8%9A%E5%8F%98%E7%8E%B0%E5%89%8D%E7%AB%AF%E7%A7%8B%E6%8B%9B%E4%B8%80%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="字节跳动-商业变现前端秋招一面"><a href="#字节跳动-商业变现前端秋招一面" class="headerlink" title="字节跳动-商业变现前端秋招一面"></a>字节跳动-商业变现前端秋招一面</h1><p>面试时长1小时8分钟，字节的面试是经历过所有的面试中最能学到东西的</p><p>第一次面试字节的时候，面试官跟我讨论了一小时的网络优化，但是当时忘记写笔记了，也就只能存在于我的记忆中了</p><p>这是第二次面试，面试部门是商业变现团队，面试官也是非常准时的，也学到了很多东西。</p><h2 id="面试内容"><a href="#面试内容" class="headerlink" title="面试内容"></a>面试内容</h2><ul><li>实习时的工作内容</li><li>面向对象的特点</li><li>以“将大象放入冰箱”为例用伪代码区分一下面向对象、面向过程和函数式编程</li><li>javaScript的数据类型（基础类型、引用类型）</li><li>怎样判断一个变量是数组还是对象（<code>Array.prototype.toStrring()</code>、<code>Array.isArray</code>）<ul><li><code>Array.prototype.toStrring()</code>与<code>tostring()</code>的区别（前者属于严格模式）</li></ul></li><li>了解过flex布局吗，说一下flex的常用属性(<code>flex</code>、<code>flex-direction</code>、<code>flex-wrap</code>、<code>flex-flow</code>、<code>justify-content</code>、<code>align-items</code>、<code>flex-grow</code>、<code>flex-shrink</code>)<font style="color: red">处于复习考虑，之后应该会根据这次面试的问题发一篇系统复习的文章</font></li><li>怎样实现一个瀑布流布局（absolute、flex、column-count+column-gap、js计算缩放）</li><li>手动实现一个bind函数，并挂载在原型上</li><li>对一个已知二叉树实现输出一个包含每一层最大值的数组</li></ul><p>两道编程题都出现了思路正确但是最终实现出现小问题的情况，都差一步，但是积极地跟面试官讨论了我的想法与思路，也获得了不少经验与知识。</p><p>一小时的时间大多数时间都耗费在代码编写上，但是的确是更加专业化的面试，最后面试官还给了我很好的建议，面试中也积极地对我的回答进行引导，很开心能学到很多知识，比某易强太多了，积累经验，正视问题，相信未来的路会走的更远！</p>]]></content>
      
      
      <categories>
          
          <category> 校招 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 校招 </tag>
            
            <tag> 字节跳动 </tag>
            
            <tag> 秋招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MVC模式、MVP模式与MVVM模式</title>
      <link href="/2020/11/19/MVC%E6%A8%A1%E5%BC%8F%E3%80%81MVP%E6%A8%A1%E5%BC%8F%E4%B8%8EMVVM%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/11/19/MVC%E6%A8%A1%E5%BC%8F%E3%80%81MVP%E6%A8%A1%E5%BC%8F%E4%B8%8EMVVM%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="MVC模式、MVP模式与MVVM模式"><a href="#MVC模式、MVP模式与MVVM模式" class="headerlink" title="MVC模式、MVP模式与MVVM模式"></a>MVC模式、MVP模式与MVVM模式</h1><p>在学习编程的过程中，我们或多或少都听说过这几种模式：MVC、MVP与MVVM，今天用一个篇幅来总结一下我认知中的三种模式</p><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC模式的意义是软件可以分为三个部分：</p><ul><li>视图（View）：用户界面</li><li>控制器（Controller）：业务逻辑</li><li>模型（Model）：数据模型</li></ul><p>MVC模式的基础通讯逻辑是这样的：</p><ol><li>View传送指令到Controller</li><li>Controller完成业务逻辑后，会要求Model改变状态</li><li>Model数据更新后将数据发送给View，用户得到反馈</li></ol><h3 id="互动模式"><a href="#互动模式" class="headerlink" title="互动模式"></a>互动模式</h3><p>MVC有两种互动模式，一种是通过View接收指令，另一种是通过Controller接收指令</p><ol><li>我们使用View接收指令时，View会将指令发给Controller进行逻辑处理，Controller处理以后会通知Model进行修改，随后Model通知View进行更新</li><li>当我们使用Controller接受指令时，Controller接收到指令，然后通知Model进行数据修改，Model负责通知View进行视图更新。</li></ol><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015020106.png"><br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015020107.png"></p><h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>MVP模式中Controller变成了Presenter，同时也改变了通信方向<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015020109.png"></p><p>在MVP的模式下View与Model不再发生任何交互，所有的一切都通过Presenter进行通信</p><p>Presenter在这里负责所有的业务逻辑处理，View也就成为了“被动视图”</p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVVM则是我们近些年听到最多的模式，当前应用最广的VUE、Angular与React都是属于MVVM模式的框架</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015020110.png"></p><p>MVVM &#x3D; Model + View + ViewModel</p><p>这里的View与ViewModel的通信方式是双向绑定，View的所有变动都会体现在ViewModel中，由ViewModel进行逻辑处理并且通知Model进行数据更新，反过来一样，当Model中数据进行更新时也同时在ViewModel中进行逻辑处理，然后ViewModel会通知View进行视图更新</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上三种模式对于编程规范甚至是了解框架原理都非常重要，有了模式的基础我们会更好地了解框架地做法甚至时逻辑地实现，能够有效减少无用代码的编写</p><p>当然以上大多都是参考自阮一峰老师的《MVC，MVP 和 MVVM 的图示》一文</p>]]></content>
      
      
      <categories>
          
          <category> 架构模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端架构 </tag>
            
            <tag> 模式 </tag>
            
            <tag> MVC </tag>
            
            <tag> MVP </tag>
            
            <tag> MVVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>心情驿站</title>
      <link href="/2020/10/29/%E5%BF%83%E6%83%85%E9%A9%BF%E7%AB%99/"/>
      <url>/2020/10/29/%E5%BF%83%E6%83%85%E9%A9%BF%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="心情驿站"><a href="#心情驿站" class="headerlink" title="心情驿站"></a>心情驿站</h1><p>怎么说呢在写这篇博客对的时候真的很纠结，虽然知道可能看到的人并不多，而且应该都是我身边的朋友们，但是一样很纠结。</p><p>今天是10.29，可能这一天我会一直记得吧，网易的面试真的打击了我的自信心，这真的第一次快要把我击垮了，虽然只是刚刚面试结束，但是我基本已经知道了凉凉的结果。</p><p>我现在的心情算是很烦躁吧，我突然间不知道我学习了这么久有什么意义，我甚至不知道接下来我该怎么做，第一次感觉很委屈也很无奈，上午面试官那句“我没看到你有什么亮点”真的很打击人，可能真的存在差距吧，但是我真的是不服气，都是同龄人凭什么别人能做到的我做不到，我不信，但也没有什么办法，选择的这条路真的非常艰辛，可能他们考研的、考公的看到的是竞争者的压力，是十几比一的录取率，但是我真的发自内心的觉得没有比就业更难的选择了，可能我还会继续努力吧，这一篇博客就当是减轻一下心中的压力吧，真的会很累，心累，这两个月的实习每天心态都在转变，可能真的从内心已经准备辞职了，最后一个月满三个月来 纪念我的第一次实习经历，开心难过这段时间都经历了，技术上感觉在这里已经没有办法更加精深了，所以也没有继续的必要了。。。</p><p>这一个月来经历了感情的失败、求职的失败，身心俱疲。。。。。。</p><p>但是还有着内心的那份不服输，我不想平凡的过完最后的这一年大学生活，所以依旧会为了未来努力的！！！</p><p>接下来的时间应该会继续学习我需要学习的知识：React、vue3.0、flutter、Next.js</p><p>我也会在学习的同时继续更新我的博客，今天应该也会把网易的三次面试题目与过程发在博客上，记录第二次大厂三面吧。</p><p>希望未来能够变得更强，算是一次激励吧，在这篇记录写下以后还要继续努力，也希望未来会越来越好，许愿未来，当我拿到offer的时候回来还愿！！！</p><p>加油，为了自己，为了未来！！！</p>]]></content>
      
      
      <categories>
          
          <category> 心情驿站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心情 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网易互娱前端面试</title>
      <link href="/2020/10/29/%E7%BD%91%E6%98%93%E4%BA%92%E5%A8%B1%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
      <url>/2020/10/29/%E7%BD%91%E6%98%93%E4%BA%92%E5%A8%B1%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="网易互娱前端面试记录"><a href="#网易互娱前端面试记录" class="headerlink" title="网易互娱前端面试记录"></a>网易互娱前端面试记录</h1><p>怎么说呢，很开心能走到三面吧，但是最后结果应该不会很理想，就先写一篇博客记录一下我的面试中遇到的问题以及难点吧（对我来说的难点）。</p><h2 id="一面（27min）"><a href="#一面（27min）" class="headerlink" title="一面（27min）"></a>一面（27min）</h2><ol><li>Vue中<code>nextTick()</code>的内部实现方式</li><li>Vue的数据传输方式</li><li>js的继承方式（构造函数继承，es6的extends继承，原型链的继承方式）</li><li>什么是事件冒泡与默认事件</li><li>事件冒泡的阻止方式<ol><li><code>window.event.cancelBuddle = true</code>，IE特有，Google支持，火狐不支持</li><li><code>e.stopPropagation()</code>，Google和火狐都支持</li></ol></li><li>编程题：大驼峰转换小驼峰（HelloWorld &#x3D;&gt; hello_world）</li></ol><p>一面结束本来觉得凉了，因为自我感觉不是很好，但是过了三天收到了二面的邀请</p><h2 id="二面（40min）"><a href="#二面（40min）" class="headerlink" title="二面（40min）"></a>二面（40min）</h2><ol><li>cookie设置<code>http-only</code>的作用</li><li>Vue的响应式原理（<code>Object.defineProperty()</code> + 订阅者-发布者）</li><li>Vue-Router的两种模式与区别（hash方式、history方式）</li><li>Vuex的基础作用、用法和使用场景（<code>State</code>、<code>Mutations</code>、<code>Actions</code>、<code>Getters</code>、<code>Modules</code>）</li><li>前端跨域的方法（CORS、JSONP、Nginx）</li><li>CSS盒模型</li><li>响应式的三栏布局实现</li><li>前端安全以及防御手段（说了中间人攻击、CSRF跨域请求伪造、XSS跨站脚本攻击）</li><li>上传文件时Ajax得到写法、上传文件的消息头</li><li>编程题：对数组的随机取值做顺序减法</li></ol><p>二面结束感觉还算可以，第三天的时候准时收到了三面邀请</p><h2 id="三面（30min）-痛苦之源"><a href="#三面（30min）-痛苦之源" class="headerlink" title="三面（30min）- 痛苦之源"></a>三面（30min）- 痛苦之源</h2><ol><li>自我介绍的时候说了实习，所以第一个问题说的就是实习的工作内容</li><li>实习时接触的技术以及做过的项目</li><li>Vue的响应式</li><li>Vue与React的区别（从这里开始力不从心）</li><li>了解过移动端技术吗（说了原生的APP以及移动端项目的300ms点击延迟）</li><li>了解后端技术吗？我说了解</li><li>那么数据库索引的底层实现方式是什么（What？？？我学前端问我数据库的底层实现？？？）</li><li>了解过跨平台技术吗？简单说一下Flutter（真的只是瞟过一眼，实话实说了，没有办法）</li><li>了解5G吗？说一下5G的实现原理是什么！（。。。只能说我真滴不知道，我投的Web前端问这些做什么？？？）</li><li>了解人工智能吗？能不能说一下人工智能的技术（我说了神经网络、爬虫和决策树）</li><li>上面这些问题没有看到你的亮点在哪里啊，你说一下你有什么亮点的地方（WTF！问这些问题我还有什么亮点，你为啥不去问问前端为啥不去干后端，不去干通信，有毒！！！）</li><li>反问环节： 对我这次的面试做一个评价吧，有什么指点！</li><li>面试官说还需要拓宽技术的广度，加深单项技术的深度，面试结果三天内通知</li></ol><p>三面就这么结束了，我也很是无奈，真的已经尽力了，很打击人，但是我真的瞬间有点累了，甚至有点控制不住我自己了，10.29我其实已经预测到了结果，我觉得基本无缘了，也就侧面意味着我的秋招到此基本结束了，坐等一封感谢信了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>决定了12月初要辞职了，精深技术，留出时间来做我的毕业设计与毕业论文，年后可能还会拼一次春招吧，真的好难，也累了，依旧要咬牙挺着，最后挣扎一次吧，如若无缘也就无缘了，求职之旅真的很累，受到过歧视受到过不公的对待都挺过来了，我相信未来的光明，为了这一份信念还会努力的！！！！</p>]]></content>
      
      
      <categories>
          
          <category> 校招 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校招 </tag>
            
            <tag> 秋招 </tag>
            
            <tag> 网易 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS盒模型</title>
      <link href="/2020/10/22/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/10/22/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h1><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>CSS盒模型又被称为框模型，包含元素内容(<code>Content</code>)、内边距(<code>padding</code>)、边框(<code>border</code>)、外边距(<code>margin</code>)</p><p>CSS外边距叠加时会发生合并，使用BFC可以有效解决没必要的边距重合</p><blockquote><p>box-sizing: content | border-box | inherit</p></blockquote><ul><li><strong>content-box：</strong> <code>box-sizing</code>的默认值，可以使设置的宽度与高度应用到元素的内容框，盒子的<code>width</code>仅包含内容(content)<ul><li>盒子总宽度 &#x3D; <code>margin</code> + <code>padding</code> + <code>border</code> + <code>width</code>;</li></ul></li><li><strong>border-box：</strong> 怪异盒模型计算方式，设置的<code>width</code>包含除<code>margin</code>外的边框、内边距、内容框的总宽度，即<code>width = content + padding + border</code><ul><li>盒子总宽度 &#x3D; <code>margin</code> + <code>width</code></li></ul></li><li><strong>inherit：</strong> 规定从父元素继承<code>box-sizing</code>的属性值</li></ul><h2 id="标准盒模型与IE盒模型"><a href="#标准盒模型与IE盒模型" class="headerlink" title="标准盒模型与IE盒模型"></a>标准盒模型与IE盒模型</h2><p>标准盒模型也就是我们上文中提到的默认值方式<code>content-box</code>，而IE盒模型，也就是我们常说的怪异盒模型，它的计算宽度方式就是<code>border-box</code>的计算方式，</p><p>在IE浏览器中IE9以下（IE6.IE7.IE8）的版本触发怪异模式，其他浏览器中会默认为W3c标准模式。原因是doctype协议缺失</p><p>如果我们定义了完整的doctype的标准文档类型，那么无论是哪种模型情况，最终都会触发标准模式。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这应该是我的博客中最短的一篇，但是并不影响它的重要性，甚至可能在之后的日子里我还会发布很多这样的文章来补充我的知识盲区，欢迎关注！</p>]]></content>
      
      
      <categories>
          
          <category> Css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS协议</title>
      <link href="/2020/10/09/HTTPS%E5%8D%8F%E8%AE%AE/"/>
      <url>/2020/10/09/HTTPS%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h1><p>伴随用户的安全意识增强，网络协议也开始向Https过度，目前大多数的网站与APP都是使用的Https协议</p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>在我之前的博客中由写过http的几种协议的比较，这里就简单介绍一下</p><p>HTTP协议的缺点：</p><ul><li>通信使用明文</li><li>不会对通信方的身份进行验证</li><li>无法验证报文的完整性</li></ul><h3 id="通信使用明文"><a href="#通信使用明文" class="headerlink" title="通信使用明文"></a>通信使用明文</h3><p>也就是说在HTTP协议中所有的数据传输都是在明文情况下进行的，也就导致了如果通信被窃听，窃听者根本无需花费任何成本就能直接查看到我们传输的数据详细内容</p><h3 id="不验证通信方身份"><a href="#不验证通信方身份" class="headerlink" title="不验证通信方身份"></a>不验证通信方身份</h3><p>不验证通信方的身份会导致通信过程被窃听后，可能遭遇伪装，并且攻击者可以使用伪装身份与己方机型通信</p><h3 id="法验证报文的完整性"><a href="#法验证报文的完整性" class="headerlink" title="法验证报文的完整性"></a>法验证报文的完整性</h3><p>无法验证报文的完整性，也就意味着数据在传输过程中可能被修改，也就造成了数据的不真实</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>对于明文传输的问题，我们可以使用密文进行传输，这样即使数据被窃听，攻击者依旧需要耗费大量的时间与精力来进行破解，间接提升了数据的安全性</p><p>要想对通信方的身份进行验证，我们可以使用与后端相同的方式，在网络数据参数中生成一个token，请求与应答时都通过token来进行身份的验证</p><p>验证报文完整性的方法就是使用MD5&#x2F;SHA1等算法进行完整性验证，对方使用相同的算法生成散列值，通过对比散列值，即可验证数据的完整性</p><p>为了解决以上的问题，HTTPS协议就诞生了：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https = http + 加密 + 认证 + 完整性验证</span><br></pre></td></tr></table></figure><p>加密、认证和完整性验证，这些特点TCP&#x2F;IP中已经提供了一个用于数据安全传输的协议，即SSL协议（Secure Socket Layer）安全套接层，虽然是基于TCP实现的，但是它并不是应用层的协议，他是位于应用层与传输层之间的协议，其存在的目的就是为上层的应用层协议提供安全的传输通道</p><p>因此HTTPS的构成也就变成了</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Https = Http + SSL</span><br></pre></td></tr></table></figure><p>因此所谓的https报文也就是SSL的报文</p><h2 id="SSL协议"><a href="#SSL协议" class="headerlink" title="SSL协议"></a>SSL协议</h2><p>SSL安全套接层，是一种位于应用层与传输层之间，为网络通信提供安全以及完整性验证的一种网络协议</p><p>相对于TCP与HTTP协议，SSL协议要更加复杂，由于建立在TCP协议之上，所以在使用SSL协议之前需要进TCP协议的三次握手来与服务器建立连接，然后再进行SSL的握手</p><h2 id="SSL握手"><a href="#SSL握手" class="headerlink" title="SSL握手"></a>SSL握手</h2><p>根据上述图片可知，SSL握手阶段如下：</p><ol><li>客户端先向服务端发送一个消息，内容包括：客户端支持的加密方式、客户端支持的压缩方法、SSL的版本号、客户端生成的随机数，以及文本内容等</li><li>服务器接收消息后回发一个文本消息，并携带从客户端支持的加密方式中选择的加密方式，服务端生成的随机数。服务端的SSL版本号等</li><li>随后服务端会给客户端发送一个Certificate（证书）报文，其中包含服务端的公钥证书</li><li>紧接着服务端向客户端发送Server Hello Done，表示最初的协商握手过程结束</li><li>客户端接收到握手结束的消息后，以Client Key Exchange作为回应。此报文中包含通信加密过程中使用的一种被称为Pre-master secret的随机密码串，并使用第三步接收到的公钥证书进行了加密</li><li>接着客户端会发送Client Cipher Spec报文，该报文会告知服务端，在此步骤之后数据将使用第五步中生成的master secret进行加密</li><li>随后客户端会发送Finish报文。此报文会包含连接至今所有报文的整体校验值，以供完整性校验</li><li>服务端接收到客户端发送的Change Cipher Spec报文后，同样以Change Cipher Spec报文作为回应</li><li>接着服务端发送Finish报文给客户端，表示服务端已正确解析客户端发送的整体校验值，至此，SSL握手的过程结束。</li><li>随后开始使用http协议传输使用master secret加密过的数据</li></ol><h3 id="描述过程"><a href="#描述过程" class="headerlink" title="描述过程"></a>描述过程</h3><ol><li>前面两个步骤的作用是协商加密算法以及传输各自生成的随机数（为后续的master secret做准备）的过程</li><li>第三步是服务端将自己的证书发送给客户端，这个证书中包含一个数字签名（CA签名）和服务端CA证书的公钥，客户端对证书中包含的服务端信息进行Hash，同时使用接收到的公钥对数字证书进行解密，获取其中的Hash值，与前面计算出的Hash值进行对比。即可验证证书的有效性（完整性&amp;真实性）</li><li>服务端收到客户端发送的Change Cipher Spec（第五步），会使用自己的私钥进行解密，获取报文中的Pre-master secret，这时通信双方都拥有对方的Random（前两步生成的随机码），Pre-master secret，以及自身的Random，将三个数作为种子通过算法生成master secret，用来加密后续Http请求过程中的数据</li></ol><h2 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h2><p>在我们对信息进行加密的时候，会分为两个类别，一类是对称加密，二另一类是非对称加密</p><ul><li><strong>对称加密：</strong> 即双方使用约定好的解密&#x2F;加密方式进行加密，双方方式一致，即为对称加密，对称加密是很早提出来的方式，而现在在数据传输中面临的问题是我们如何将密钥发送给对方，在密钥的传输过程中很容易就会被黑客截获密钥，此时我们传输的密文信息也就是形同虚设</li><li><strong>非对称加密：</strong> 非对称加密是为了解决对称加密的密钥易被截获的缺点而提出来的方案，当A和B进行数据传输时，A通过非对称加密生成两个密钥，一个用于加密的公钥，一个用于解密的私钥，A在传输时将公钥交给了B，B在数据传输时使用公钥加密而A使用密钥解密，这样就形成了非对称加密，也就是说哪怕黑客截取了公钥与信息页无从得知具体的信息内容。</li></ul><p>但是事实上非对称加密的速度要慢于对称加密，因此我们一般都是用非对称加密的方式传输对称加密中生成的密钥</p><p>在上面的介绍中其实页存在两个问题：</p><ul><li>怎样保证A给B的公钥是正确的，即公钥没有被黑客篡改？</li><li>怎样保证A收到B的信息是正确的？</li></ul><p>对于第二个问题在网络中我们一般使用了<strong>第三方公证处</strong>的方法，A生成公钥以后不仅交给B一份，也会在第三方公证处进行一次认证，将公钥交给第三方，B拿到公钥后去公证处认证对比一次就会知道公钥的对错，但是这样就形成了一个新的问题：如果去第三方认证时被黑客拦截了，去假的公证处拿到一个假的密钥怎么办？</p><p>对这个问题涉及到以下几点：</p><ul><li>摘要算法（MD5）</li><li>数字证书与数字签名</li><li>自签名证书与跟证书</li><li>证书链</li></ul><h2 id="证书链与摘要算法"><a href="#证书链与摘要算法" class="headerlink" title="证书链与摘要算法"></a>证书链与摘要算法</h2><p>根据非对称加密算法，公钥加密的数据只能使用私钥进行解密，相反的私钥加密的数据也就只能使用公钥进行解密。</p><p>所有的操作系统在出厂时都会安装一个根证书，我们可以先忽略证书的意义，值知道里面存放有公钥，这个我们可以认为是最顶级的机构 <strong>（CA Certificate Authority, 证书认证机构）</strong> 的公钥。</p><p>当服务端想要提价自己的公钥时，就会去计算机中证书的发放机构进行认证，这时机构会将服务端的公钥以及证书信息（颁发者时间等）<strong>生成摘要</strong>，然后再用根证书对应机构的密钥加密这段摘要，这个操作也就是<strong>数字签名</strong>，然后回返回一个证书给服务端，随后服务端将这个证书给浏览器，浏览器使用公钥解密后可以得到服务器的公钥、证书的数字签名、签名的计算方法，重新对签名进行计算后对比就可以知道证书有没有被修改过，也就保证了通信安全</p><p>当然不可能我们每一次都要直接请求根证书的发放机构，这种情况下就产生了一级CA、二级CA等，这些CA本身就是通过了根证书CA的认证，他们也拥有自己的密钥，根证书的CA也给他发放了一个证书，包含了根证书机构对应的信息，并使用私钥完成了数字签名，而一级CA发放给服务端的证书里面也包含有这一份证书，浏览器接收证书后，判断这是否是一个一级证书，使用根证书的公钥对一级证书的摘要进行解密对比，就可以验证一级证书的有效性，随后获得一级证书的公钥对服务器信息的摘要进行解密对比，验证服务器信息的有效性，以此类推到二级、三级证书，也就形成了<strong>证书链</strong>。</p><h2 id="简述通信过程"><a href="#简述通信过程" class="headerlink" title="简述通信过程"></a>简述通信过程</h2><p>其实详细的通信过程就是上面SSL的通信过程，这里使用简短的概括说一下加入证书后的HTTPS通信</p><ol><li>服务端向CA机构申请数字证书，里面包含有自己的公钥以及证书链</li><li>服务端将自己的证书交给浏览器</li><li>浏览器对证书链进行层层验证，最终获得服务端的公钥</li><li>浏览器生成对称加密算法的密钥，并通过服务端公钥加密后发送给服务端</li><li>服务端使用私钥解析后获得对称加密的密钥</li><li>浏览器与服务器开始使用密钥进行通信</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>HTTPS的过程基本就如上面所述，HTTPS协议对于前端来说是一个非常重要的概念，这里阐述的可能也并不详细，参考了一些掘金的文章</p><ul><li><a href="https://juejin.im/post/6844903504046211079">《谈谈Https》</a></li><li><a href="https://juejin.im/post/6844903993462751240">《搞懂Https》</a></li></ul><p>希望这些对读者了解HTTPS能够有所帮助！</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 面试 </tag>
            
            <tag> Http </tag>
            
            <tag> Https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue学习笔记 — 整体流程</title>
      <link href="/2020/09/20/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E2%80%94-%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/"/>
      <url>/2020/09/20/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E2%80%94-%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue学习笔记-—-整体流程"><a href="#Vue学习笔记-—-整体流程" class="headerlink" title="Vue学习笔记 — 整体流程"></a>Vue学习笔记 — 整体流程</h1><p>Vue的整体流程对一些业务实现很有帮助，当出现一些bug时我们可以根据所使用功能的内部实现，快速、精确地定位问题所在，当我们理解了Vue.js能提供的能力边界在哪里的时候，我们就可以最大限度地发挥它的价值</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><ul><li><p>script # 与构建相关的脚本和配置文件</p></li><li><p>dist # 构建后的文件</p></li><li><p>flow # Flow的类型声明</p></li><li><p>package # <code>vue-server-randerer</code>和<code>vue-template-compiler</code>，他们可以作为单独的npm包发布</p></li><li><p>test # 所有的测试代码</p></li><li><p>src # 源代码</p><ul><li>compiler # 模板编译相关的代码（解析器、、优化器、代码生成器）</li><li>core # 通用的、与平台无关的运行时代码<ul><li>observer # 变化侦测相关代码</li><li>vdom # 虚拟dom相关代码</li><li>instance # Vue.js 实例的构造函数与原型方法</li><li>global-api # 全局的API代码</li><li>components # 通用的抽象组件</li></ul></li><li>server # 服务端渲染相关代码</li><li>platforms # 特定平台相关代码</li><li>sfc # 单文件组件（*.vue文件）解析逻辑</li><li>shared # 整个项目的公用工具代码</li></ul></li><li><p>types # TypeScript类型定义</p><ul><li>test # 类型定义测试</li></ul></li></ul><p>当使用vue-loader或vueify的时候，*.vue文件内部的模板会在构建时预编译成JavaScript。</p><h2 id="开发环境与生产环境模式"><a href="#开发环境与生产环境模式" class="headerlink" title="开发环境与生产环境模式"></a>开发环境与生产环境模式</h2><p>对于UMD版本来说，开发发环境和生产环境二者的模式是硬编码的：开发环境下使用未压缩的代码，生产环境下使用压缩后的代码。</p><p><strong>CommonJs</strong> 和<strong>ES Module</strong> 版本应用于打包工具，因此Vu.js不提供压缩后的版本，需要自行将最终的包进行压缩。他们还保留原始的<code>process.env.NODE_ENV</code>检测，这会决定他们应该在什么模式下运行。我们应该使用适当的打包工具来替换这些环境变量，以便控制Vue.js所运行的模式。把<code>process.env.NODE_ENV</code>替换为字符串字面量，同时使用<code>UglifyJS</code>之类的压缩工具完全删除仅供开发环境的代码块，从而减小最终文件的大小。</p><p>在Vue.js中，我们使用<code>DefinePlugin</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">export</span> = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> webpeck.<span class="title class_">DefinePlugin</span>(&#123;</span><br><span class="line">            <span class="string">&#x27;process_env&#x27;</span>: &#123;</span><br><span class="line">                <span class="attr">NODE_ENV</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="string">&#x27;production&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><p>Vue的整体分为三个部分：核心代码、开平台相关和公用工具函数。</p><p>同时，其架构也是分层的，最上层是入口，最底层是普通的构造函数。在最底层与最顶层中间，我们需要逐渐增加一些方法与属性，而构造函数上一层的一些方法会最终添加到构造函数的<code>prototype</code>属性中，再上一层的方法最终会添加到构造函数上，这就叫做全局的API(Global API)，例如常用的<code>Vue.use</code>，<code>Vue.$set</code>等。也就是说，先在构造函数的prototype属性中添加方法后，再向构造韩寒申诉自身添加API。再向上就是跨平台的相关内容了。在我们进行构建时，首先会选择一个平台，然后将特定于这个平台的代码添加加载到构建文件中，再上一层是渲染层，其中有两个部分，分别是服务器渲染和编译器相关内容，这部分的内容是可选的，构建时会根据构建的目标文件来选择是否需要将编译器加载进来。</p><p>最顶层的入口，其实时相对来说的，对于构建工具以及使用Vue.js的开发者来说，这是入口，而对于Vue.js自身来说，这时出口。</p><p>就整体来看，下面三层属于核心代码区域，而上面三层是属于与平台相关的代码。</p><p><img src="https://s1.ax1x.com/2020/09/20/wogFE9.png"></p><p>这里以构建Web平台下运行的文件为例，如果我们构建的是完整版本，我们会选择Web平台的入口文件开始构建，这个文件会最终导出一个Vue构造函数，导出前回想Vue的构造函数中添加一些方法，流程如下：先将Vue构造函数的prototype属性上添加一些方法，然后向Vue构造函数自身添加一些全局的API，接着将平台特有的代码导入进来，最后将编译器导入进来，最终将所有代码通Vue构造函数仪器导出</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于实习原因，更新无固定时间，这一篇就总结记录了一下大体上的整体流程以及全局的架构设计，更多的细节例如API实现以及生命周期等会记录再后续的博客中。</p>]]></content>
      
      
      <categories>
          
          <category> Vue学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue2 </tag>
            
            <tag> Vue原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript学习笔记</title>
      <link href="/2020/09/13/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/09/13/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript学习笔记"><a href="#TypeScript学习笔记" class="headerlink" title="TypeScript学习笔记"></a>TypeScript学习笔记</h1><p>TypeScript是javaScript的超集，有一部分的语法与ES6相似，且更加趋近于面向对象编程，是现如今前端语言发展的主流方向</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用<code>npm installl -g typescript</code>进行安装</p><p>安装之后可以使用<code>tsc -v</code>查看解析器的版本号同时验证安装</p><p>tsc的作用就是将ts转换为浏览器、nodejs可识别的js代码</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>首先编写ts文件，编写后在终端运行<code>tsc ***.ts</code>的命令，可以将ts文件编译为一个node或浏览器可识别的js文件，然后运行即可</p><p>在node中运行ts会明显感觉到过于复杂，因此可以使用ts-node工具</p><p><strong>安装方式：</strong> <code>npm install -g ts-node</code></p><p><strong>使用方式：</strong> <code>ts-node ts文件名</code></p><p><strong>生成配置：</strong> <code>tsc --init</code></p><p><strong>自动编译：</strong> 配置之后修改tsconfig文件实现自动编译 在vscode中点击终端&#x3D;&gt;点击运行任务 &#x3D;&gt;点击tsc监视器</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>TypeScript规定： 在声明变量时必须指定变量类型</p><p>声明方式： </p><ul><li><code>let 变量名 : 变量类型;</code></li><li><code>let age: number;</code></li><li><code>let myName: string;</code></li></ul><p>TypeScript兼容所有JavaScript的数据类型： string, number, boolean, undefined, null, Symbol</p><h3 id="undefined与null"><a href="#undefined与null" class="headerlink" title="undefined与null"></a>undefined与null</h3><p>在<code>javascript</code>中undefined与null都是变量的值，undefined代表一个没有被初始化的变量，null指向一个空的对象</p><p>在<code>Typescript</code>中undefined与null都是一种数据类型，undefined类型的变量，只能存储undefined的值，null类型的变量，只能存储null的值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a1</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span>; <span class="comment">//√</span></span><br><span class="line">a1 = <span class="number">10</span>; <span class="comment">//×</span></span><br><span class="line"><span class="comment">//undefined类型的变量只能存储undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a2</span>: <span class="literal">null</span> = <span class="literal">null</span>; <span class="comment">// √</span></span><br><span class="line">a2 = <span class="string">&quot;aaa&quot;</span> <span class="comment">// ×</span></span><br><span class="line"><span class="comment">//null类型的变量只能存储null</span></span><br></pre></td></tr></table></figure><p>undefined与null类型的变量可以作为其他类型变量的值</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a2</span>: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">a3</span>: <span class="built_in">string</span> = a2;</span><br></pre></td></tr></table></figure><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>声明方式：<code>let 变量名: 数据类型1 | 数据类型2</code></p><p>变量取值时可以是两种类型中的任意一种</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">res</span>: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">res = <span class="string">&quot;aaaa&quot;</span>; <span class="comment">//√</span></span><br><span class="line">res = <span class="number">123</span>; <span class="comment">//√</span></span><br><span class="line">res = <span class="literal">false</span>; <span class="comment">//×</span></span><br></pre></td></tr></table></figure><h3 id="any类型"><a href="#any类型" class="headerlink" title="any类型"></a>any类型</h3><p>any类型代表可以用来存储任意类型的数据，定义为any的变量可以被赋予任意类型的值</p><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>类型断言等同于其他语言中的类型转换，它 不会对 运行时产生影响，仅仅只是在编译阶段起作用</p><p>类型断言有两种方式，其一是尖括号法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">someLength</span>: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).<span class="property">length</span></span><br></pre></td></tr></table></figure><p>将someValue从any类型强制转换为了string类型</p><p>断言的第二种方式是as方式，也是做常用的断言方式 ：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">someLength</span>: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">length</span></span><br></pre></td></tr></table></figure><p>写法虽然有些不同，但是用法一致，代表的意义也是一样的，如果更加熟悉后端语言开发，那么肯定会对第一种写法情有独钟，因为它更加接近java\c++的类型转换写法，因此两种写法没有谁好谁坏，仅凭个人喜好</p><p><font style="color:red"><strong>注意：</strong>当我们在Typescript中使用JSX时，只允许使用as语法！！！</font></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="ES6定义"><a href="#ES6定义" class="headerlink" title="ES6定义"></a>ES6定义</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;function&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;function&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是ES5中定义函数的两种方式</p><h3 id="TS定义"><a href="#TS定义" class="headerlink" title="TS定义"></a>TS定义</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//限定返回值的定义方式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">run</span>(<span class="params"></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;run&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无返回值的定义方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">run2</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名函数方法</span></span><br><span class="line"><span class="keyword">var</span> fun2 = <span class="keyword">function</span>(<span class="params"></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;fun2&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义方法传参</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getInfo</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span>---<span class="subst">$&#123;age&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getInfo</span>(<span class="string">&#x27;ryz&#x27;</span>, <span class="number">20</span>)) <span class="comment">// ryz---20</span></span><br></pre></td></tr></table></figure><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>es5中实参与形参可以不一样，但是ts中必须一致，如果想要不一样，必须进行配置</p><p>使用<code>?:</code>的方式定义形参，代表为可选参数，可传可不传</p><p>可选参数必须写在形参的最后位置</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getInfo</span>(<span class="params">name: <span class="built_in">string</span>, age?: <span class="built_in">number</span></span>):<span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(age) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span>---<span class="subst">$&#123;age&#125;</span>`</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span>---年龄保密`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getInfo</span>(<span class="string">&#x27;aaaa&#x27;</span>, <span class="number">12</span>)) <span class="comment">// aaaa---12</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getInfo</span>(<span class="string">&#x27;bbb&#x27;</span>)) <span class="comment">// bbb---年龄保密</span></span><br></pre></td></tr></table></figure><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>可以使用<code>age:string = 20</code>的方式定义默认参数</p><h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p>可以使用扩展运算符<code>...</code>对剩余参数进行遍历</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">...result:<span class="built_in">number</span>[]</span>):<span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; result.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        sum+=result[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>在java中函数重载意味着同名的函数可以通过传入不同的参数达到实现不同目的的效果</p><p>在ts中的函数重载与java中不一样，ts中的重载仅仅是为了类型检验，限制出入类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">css</span>(<span class="params">config:<span class="built_in">string</span></span>):<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">css</span>(<span class="params">config:<span class="built_in">string</span>, value: <span class="built_in">number</span></span>):<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">css</span>(<span class="params">config:<span class="built_in">any</span>, value?: <span class="built_in">number</span></span>):<span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;config&#125;</span>---<span class="subst">$&#123;value&#125;</span>`</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;config&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>typescript的类的定义方式与es6一致</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//es5定义</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">run</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        cnosole.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ts定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;<span class="comment">//构造函数</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_">run</span>():<span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;rrr&quot;</span>)</span><br><span class="line">p.<span class="title function_">run</span>() <span class="comment">//rrr</span></span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>可以使用原型链的方式进行继承，也可以使用<code>extends</code>关键字继承</p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p><code>public</code>、<code>private</code>、<code>protected</code>用法与java中的修饰符用法一致</p><h3 id="静态方法、静态属性"><a href="#静态方法、静态属性" class="headerlink" title="静态方法、静态属性"></a>静态方法、静态属性</h3><p><strong>ES5中的静态方法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态方法</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">run2</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="comment">//实例方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">run1</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用实例方法</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line">p.<span class="title function_">run1</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用静态方法</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">run2</span>()</span><br></pre></td></tr></table></figure><p><strong>Ts中的静态方法：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="attr">name</span>:<span class="built_in">string</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">        thi8s.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>在运动`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;print方法&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用静态方法</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">print</span>()</span><br></pre></td></tr></table></figure><p>静态方法可以直接使用类名进行调用，在静态方法中不允许调用非静态属性，只能调用静态属性</p><p>静态属性的定义与调用方式与静态方法完全一致</p><h4 id="Abstruct"><a href="#Abstruct" class="headerlink" title="Abstruct"></a>Abstruct</h4><p><strong>多态：</strong> 在父类中定义一个方法不去实现，在继承的子类中完成实现，这就是多态</p><p><code>abstruct</code>关键字定义抽象类和抽象方法，抽象类中的抽象方法不包含具体实现并且必须在派生类中进行实现，这也是多态的一种实现方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义抽象方法</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="title function_">eat</span>():<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">eat</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>+<span class="string">&quot;吃鱼&quot;</span>) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">eat</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>+<span class="string">&quot;吃肉&quot;</span>) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;cat&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;dog&quot;</span>)</span><br><span class="line"></span><br><span class="line">cat.<span class="title function_">eat</span>()</span><br><span class="line">dog.<span class="title function_">eat</span>()</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>TypeScript的核心原则之一是对值所具有的结构进行类型检查。</p><p>而接口在这里的作用就是提供自定义的第三方契约</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">LabelledValue</span> &#123;</span><br><span class="line">    <span class="attr">label</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printLabel</span>(<span class="params">labelledObj: LabelledValue</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(lavelledObj.<span class="property">label</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = &#123;<span class="attr">size</span>: <span class="number">10</span>, <span class="attr">lebel</span>: <span class="string">&quot;Size 10 Object&quot;</span>&#125;;</span><br><span class="line"><span class="title function_">printLabel</span>(myObj);  <span class="comment">//Size 10 Object</span></span><br></pre></td></tr></table></figure><p>上面的例子中，接口LabelledValue更像是一个自定义的数据类型集合，这里的接口不想其他语言一样是由函数来继承实现的，而是直接规定了值的类型，只要值的属性与类型是对的，那么就是被允许的</p><p>类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型是对的就可以了</p><h3 id="额外的属性检查和索引签名"><a href="#额外的属性检查和索引签名" class="headerlink" title="额外的属性检查和索引签名"></a>额外的属性检查和索引签名</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SquareConfig</span> &#123;</span><br><span class="line">    color?: <span class="built_in">string</span>;</span><br><span class="line">    width?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createSquare</span>(<span class="params">config: SquareConfig</span>): &#123;<span class="attr">color</span>:<span class="built_in">string</span>; <span class="attr">area</span>: <span class="built_in">number</span>&#125; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySquare = <span class="title function_">createSquare</span>(&#123;<span class="attr">colour</span>: <span class="string">&quot;red&quot;</span>, <span class="attr">width</span>: <span class="number">100</span>&#125;);</span><br></pre></td></tr></table></figure><p>细心观察我们会发现这里传入的时colour而不是color,</p><p>在javaScript中我们会认为这段代码是完全失败的，color在SquareConfig接口中是可选属性，可以不存在，width作为属性传入没有异议，但是接下来我们就要讨论colour了，这个属性直观上我们肯定觉得这个属性应该直接被编译器忽略了，是没有意义的，但是在TypeScript中就可能存在bug，对象字面量在TypeScript中会被特殊对待，会经过额外的属性检查，如果此时一个字面量存在“目标类型”中不包含的属性，那么就会得到一个错误：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySquare = <span class="title function_">createSquare</span>(&#123;<span class="attr">colour</span>: <span class="string">&quot;red&quot;</span>, <span class="attr">width</span>: <span class="number">100</span>&#125;);</span><br><span class="line"><span class="comment">// error: &#x27;colour&#x27; not expected in type &#x27;SquareConfig&#x27;</span></span><br></pre></td></tr></table></figure><p>而绕开这个检查最佳简便的办法就是使用类型断言：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySquare = <span class="title function_">createSquare</span>(&#123;<span class="attr">colour</span>: <span class="string">&quot;red&quot;</span>, <span class="attr">width</span>: <span class="number">100</span>&#125; <span class="keyword">as</span> <span class="title class_">SquareConfig</span>);</span><br></pre></td></tr></table></figure><p>最佳方式其实是使用字符串索引签名，，如果SquareConfig中带有上面定义的类型，且还会携带任意数量的其他属性，那么我们可以这样定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SquareConfig</span> &#123;</span><br><span class="line">    color?: <span class="built_in">string</span>;</span><br><span class="line">    width?: <span class="built_in">number</span>;</span><br><span class="line">    [<span class="attr">propName</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用索引签名就是能够规定，我们只对接收的color和width属性有所约束，而对于其他属性没有类型限制</p><p>还有一种方式就是将colour赋予另外一个对象变量<code>squareOption</code>，然后在传参时使用<code>squreOption</code>进行传入，这样就能绕过额外的属性检查</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> squareOption = &#123;<span class="attr">colour</span>: <span class="string">&quot;red&quot;</span>, <span class="attr">width</span>: <span class="number">100</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> mySquare = <span class="title function_">createSquare</span>(squareOption);</span><br></pre></td></tr></table></figure><h3 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h3><p>与类一样，接口也是可以进行继承的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="attr">sideLength</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square =  &#123;&#125;;</span><br><span class="line">square.<span class="property">color</span> = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">square.<span class="property">sideLength</span> = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>一个接口可以继承多个接口，那么它就拥有所有接口的属性</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型可以用于约束函数传入的数据类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//未使用泛型时</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getArray</span> = (<span class="params">value: <span class="built_in">any</span>, times: <span class="built_in">number</span> = <span class="number">5</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Array</span>(times).<span class="title function_">fill</span>(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getArray</span>(<span class="number">123</span>,<span class="number">4</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="title function_">toFixed</span>())) <span class="comment">//[&quot;123&quot;, &quot;123&quot;, &quot;123&quot;, &quot;123&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用泛型后</span></span><br><span class="line"><span class="keyword">const</span> getArray = (<span class="attr">value</span>: T,<span class="attr">times</span>: <span class="built_in">number</span> = <span class="number">5</span>): T[] =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Array</span>(times).<span class="title function_">fill</span>(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(getArray&lt;<span class="built_in">number</span>&gt;(<span class="number">123</span>,<span class="number">4</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="title function_">toFixed</span>())) <span class="comment">// [&quot;123&quot;, &quot;123&quot;, &quot;123&quot;, &quot;123&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(getArray&lt;<span class="built_in">number</span>&gt;(<span class="string">&quot;asd&quot;</span>,<span class="number">4</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="title function_">toFixed</span>())) <span class="comment">//Error</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
            <tag> 前端基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构–线性表</title>
      <link href="/2020/08/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%93%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2020/08/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%93%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构–线性表"><a href="#数据结构–线性表" class="headerlink" title="数据结构–线性表"></a>数据结构–线性表</h1><p>⚠️ <font color="red">本文中代码均使用 <strong>C++</strong> 进行编码</font></p><p><strong>线性表</strong>是线性数据结构的典型代表，线性表是一种最基本、最简单的数据结构，数据元素之间仅具有单一的前驱和后继关系。线性表不仅有着广泛应用，同时它也是其他数据结构的基础。</p><blockquote><p>线性表简称表，是n(n&gt;&#x3D;0)个具有相同数据类型的数据元素的有限序列，线性表中数据元素的个数称为线性表的长度，长度等于零时称为空表</p></blockquote><p>我们通常使用<code>ai</code>表示线性表中的第<code>i</code>个元素，而<code>a1</code>也就是线性表的第一个元素，他没有前驱，而<code>an</code>则是线性表的最后一个元素，他没有后继，其他每个元素仅有一个前驱和一个后继</p><p>线性表中一般都包含一下的方法或操作，以供我们对线性表进行各种操作：</p><ul><li>Data(用于存储数据)</li><li>InitList（创建一个新的空的线性表）</li><li>DestoryList（销毁线性表并释放空间）</li><li>Length（获取线性表长度，记线性表中元素的个数）</li><li>Get（获取线性表中第i个位置的元素）</li><li>Locate（按值查找，返回该值所对应的位置序号）</li><li>Insert（向位置i插入元素x）</li><li>Delete（删除线性表中位置i所对应的元素）</li><li>Empty（判空操作，返回一个bool值，判断线性表是否为空）</li><li>PrintList（对线性表进行遍历操作，依次输出线性表元素）</li></ul><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><blockquote><p>线性表中的顺序存储结构叫做顺序表</p></blockquote><p>顺序表是使用一段地址连续的存储单元一次储存线性表的数据元素。</p><p>由于数据表中元素类型相同，且按照一定顺序进行存储，因此我们一般使用数组来实现顺序表，这也就导致了数据元素的序号与数组下标形成了一一对应的关系。</p><p>但是由于使用数组进行存储，也就引出了一系列的问题，其中最主要的就是，我们使用数组来对顺序表进行实现，那么我们在定义顺序表时就需要给行顺序表的长度，当我们要进行增加元素操作时就需要向系统申请新的空间，而且因为使用了数组，而数组场读固定，我们通常会进行顺序表的插入、删除等操作，我们也就需要将数组的长度设置大于顺序表的长度即<code>MaxSize &gt; length</code></p><p><font style="color: red">此处添加示意图</font></p><p>设顺序表的每个元素占用c个存储单元，则第i个元素的存储位置为：</p><p><code>LOC(ai) = LOC(a1) + (i - 1) × c</code></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>由于元素类型是不确定的，因此在这里使用C++的模板机制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MaxSize = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt; <span class="keyword">class</span> <span class="title class_">SeqList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SeqList</span>() &#123;length = <span class="number">0</span>;&#125; <span class="comment">//无参构造函数</span></span><br><span class="line">    <span class="built_in">SeqList</span>(DataType a[], <span class="type">int</span> n); <span class="comment">//有参构造函数</span></span><br><span class="line">    ~<span class="built_in">SeqList</span>() &#123;&#125; <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Length</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> length;&#125; <span class="comment">//获取线性表长度</span></span><br><span class="line">    <span class="function">DataType <span class="title">Get</span><span class="params">(<span class="type">int</span> i)</span></span>;<span class="comment">//按位查找，第i个元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Locate</span><span class="params">(DataType x)</span></span>; <span class="comment">//按值查找，返回序列号</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> i, DataType x)</span></span>; <span class="comment">//插入操作，在第i个位置插入值x</span></span><br><span class="line">    <span class="function">DataType <span class="title">Delete</span><span class="params">(<span class="type">int</span> i)</span></span>; <span class="comment">//删除操作，删除第i个位置的元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">()</span></span>; <span class="comment">//遍历操作，依序输出整个顺序表</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    Datatype data[MaxSize]; <span class="comment">//存放数据元素的数组</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//线性表的长度</span></span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul><li><strong>无参构造：</strong> 只需要简单地将顺序表的长度length初始化为0</li><li><strong>有参构造：</strong> <code>SeqList(DataType a[], int n);</code>需要传入长度n以创建一个长度为n的顺序表，需要将传入的数组元素作为线性表的数据元素传入顺序表，并将传入元素的个数作为顺序表的长度<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt; SeqList::<span class="built_in">SeqList</span>(DataType a[], <span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; MaxSize) <span class="keyword">throw</span> <span class="string">&quot;非法参数&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        data[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    length = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><ol><li><p>按位查找</p><p>顺序表中第i个元素，对应数组中的下标为i-1，所以顺序表只需要一次遍历就能查找到对应位置的元素，时间复杂度即为O(1)</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt; <span class="function">DataType <span class="title">SeqList::Get</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> &amp;&amp; i &gt; length) <span class="keyword">throw</span> <span class="string">&quot;查找位置非法&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> data[i<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>按值查找</p><p>值查找的方法就是简单粗暴了，直接一次遍历，对比所有值，找到所需要元素，然后返回其序号<font color="red">（不是下标）</font>，如果不成功则返回失败标志“0”</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SeqList::Locate</span><span class="params">(DataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[i] == x)</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按值查找的平均时间性能也是O(n)，因为我们只需要进行一次循环遍历，即时对比，就能轻易找到答案</p></li></ol><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p>顺序表的增加操作应该是所有线性表操作中最麻烦的，因为涉及到顺序表的长度问题，当我们在第<code>i</code>个位置插入一个新元素<code>x</code>，则线性表长度从<code>n</code>变为<code>n+1</code></p><p>插入算法的逻辑基本上是这样的：</p><ul><li>当需要插入的位置位于末尾时，我们仅需要修改顺序表长度，并且将元素添加在末尾就可以了</li><li>当需要插入的元素不在末尾时，我们则需要逆序遍历整个顺序表，将所有的元素向后挪动一个位置，直到我们需要插入元素的第<code>i</code>个位置，然后将元素插入，最后将顺序表的长度+1即可</li><li>如果插入元素的位置不合理或表满了，那么就抛出错误即可  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SeqList::Insert</span><span class="params">(<span class="type">int</span> i, DataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length &gt;= MaxSize) <span class="keyword">throw</span> <span class="string">&quot;上溢&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i  length + <span class="number">1</span>) <span class="keyword">throw</span> <span class="string">&quot;插入位置错误&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = length; j &gt;= i; j++) &#123; <span class="comment">//数组最后一个存储位置为length - 1</span></span><br><span class="line">        data[j] = data[j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    data[i<span class="number">-1</span>] = x;</span><br><span class="line">    length ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>当元素在表尾时<code>(i = n+1)</code>，元素不需要后移，时间复杂度为<code>O(1)</code></li><li>当元素在表头时<code>(i = 1)</code>，元素需要移动n次，这是最坏的情况，时间复杂度为<code>O(n)</code></li><li>当元素在其他位置时，元素需要移动的平均时间复杂度为<code>O(n)</code></li></ul><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p>顺序表中的删除操作，需要将指定位置的元素删除，并且将指定位置之后的元素全部前移，且删除操作的时间复杂度与增加操作基本一致</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="function">DataType <span class="title">SeqList::Delete</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">0</span>) <span class="keyword">throw</span> <span class="string">&quot;下溢&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; length) <span class="keyword">throw</span> <span class="string">&quot;删除位置错误&quot;</span>;</span><br><span class="line">    x = data[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; length; j ++) &#123;</span><br><span class="line">        data[j - <span class="number">1</span>] = data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    length --;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>遍历就更简单了，直接依序输出所有元素就可以了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SeqList::PrintList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; &lt; length; i++)</span><br><span class="line">        cout&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表（Linked-List）"><a href="#链表（Linked-List）" class="headerlink" title="链表（Linked List）"></a>链表（Linked List）</h2><p>顺序表利用了数组元素在物理上的位置的邻接关系来表示线性表元素之间的逻辑关系，拥有不少优点的同时也反映出了很多的缺点：</p><ul><li>插入和删除操作都需要进行大量的移动</li><li>顺序表的容量固定，长度必须事先设定，但是如果需要存储的元素未知个数就无法确定长度了</li><li>造成存储空间的“碎片”，数组要求占用连续的存储空间，即使存储单元数超过所需的数目，如果不连续也不能使用，造成空间的“碎片”现象</li></ul><p>解决上述问题，最根本的原因其实就是静态资源分配，因此为了解决这些问题，我们可以使用链式存储来进行动态的资源分配</p><p>链表的基础实现方式很简单，就是使用任意的存储空间，对链表元素进行存储，在每一个链表结点中都存储一个指向下一个结点的指针，以便形成逻辑上的链式存储结构</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><blockquote><p>单链表就是用一组任意的存储单元存放线性表的元素，这组存储单元可以连续，也可以不连续，但是为了确定元素之间的逻辑关系，在存储数据的同时，必须存储其后继元素所在的地址信息，而这个存储单元被称为<strong>结点</strong></p></blockquote><p><img src="https://s1.ax1x.com/2020/08/03/aUnWX4.png"></p><p>data是数据域，用以存储数据元素，next是指针域（也称链域），用来存储后继结点的地址</p><p><font style="color:red">由于元素类型不确定，下面的所有代码中均默认元素为int类型</font></p><p>结点的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">bool</span> Boolean;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> DataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">DataType data; <span class="comment">//数据域</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> *next; <span class="comment">//指针域</span></span><br><span class="line">&#125;node, *pnode;</span><br></pre></td></tr></table></figure><p>为了我们能够轻易地找到链表，且因为第一个元素无前驱，我们必须对链表设置<font color="green"><strong>头指针</strong></font>指向第一个元素所在的结点；因为最后一个元素无后继，所以最后一个结点的next指向为<strong>NULL</strong></p><p><img src="https://s1.ax1x.com/2020/08/03/aaAiHx.png"></p><p>单链表的方法定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinkList</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> size;  <span class="comment">//链表长度</span></span><br><span class="line">pnode head; <span class="comment">//pnode是Node类型的指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">LinkList</span>(); <span class="comment">//无参构造函数</span></span><br><span class="line">    <span class="built_in">LinkList</span>(DataType a[], <span class="type">int</span> n);  <span class="comment">//有参构造函数</span></span><br><span class="line">~<span class="built_in">LinkList</span>();<span class="comment">//析构函数</span></span><br><span class="line"><span class="function">Boolean <span class="title">Insert</span><span class="params">(DataType, <span class="type">int</span>)</span></span>;  <span class="comment">//插入函数</span></span><br><span class="line"><span class="function">Boolean <span class="title">Del</span><span class="params">(DataType)</span></span>; <span class="comment">//删除函数</span></span><br><span class="line"><span class="function">Boolean <span class="title">IsEmpty</span><span class="params">()</span></span>;<span class="comment">//判空函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Locate</span><span class="params">(DataType x)</span></span>;<span class="comment">//按值查找函数</span></span><br><span class="line">    <span class="function">DataType <span class="title">Get</span><span class="params">(<span class="type">int</span> i)</span></span>;<span class="comment">//按位查找函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">()</span></span>; <span class="comment">//遍历函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面的方法实现顺序从易到难，可能并不按照上述方法定义的顺序。</p><h4 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h4><p>与顺序表不同，链表的构造函数中我们需要对头结点进行创建操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LinkList::<span class="built_in">LinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">head=<span class="keyword">new</span> node; <span class="comment">//创建head为node结点</span></span><br><span class="line">head-&gt;next=<span class="literal">NULL</span>;<span class="comment">//使head的next指针指向为空</span></span><br><span class="line">size=<span class="number">0</span>;<span class="comment">//初始化长度为0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>有参构造函数：</strong></p><ol><li><p>头插法</p><p>头插法就是每次都将新申请的结点插入到头结点的后面</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LinkList::<span class="built_in">LinkList</span>(DataType a[], <span class="type">int</span> n) &#123;</span><br><span class="line">    head = <span class="keyword">new</span> node;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        pnode s;</span><br><span class="line">        s = <span class="keyword">new</span> node;</span><br><span class="line">        s-&gt;data = a[i];</span><br><span class="line">        s-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next = s;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/08/03/ad1PmT.png"></p></li><li><p>尾插法</p><p>尾插法就是将每一个新申请的结点插入到终端结点的后面，将终端结点的next指向新结点，将新结点作为插入后的终端结点</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LinkList::<span class="built_in">LinkList</span>(DataType a[], <span class="type">int</span> n) &#123;</span><br><span class="line">    head = <span class="keyword">new</span> node;</span><br><span class="line">    p = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        pnode s;</span><br><span class="line">        s = <span class="keyword">new</span> node;</span><br><span class="line">        s-&gt;data = a[i];</span><br><span class="line">        p-&gt;next = s;</span><br><span class="line">        p = s;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;<span class="comment">//创建完毕后直接将尾结点的next指针赋空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>析构函数</strong>的作用的释放空间，因此我们需要对链表进行从头至尾的释放：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LinkList::~<span class="built_in">LinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">pnode pn;</span><br><span class="line">pn=head;</span><br><span class="line"><span class="keyword">while</span>(pn!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">head=head-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> pn;</span><br><span class="line">pn=head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h3><p>其实遍历的方式与上面的析构函数中的实现方式基本一致，从我们定义的头结点开始，判断next指针是否为空，若为空则证明链表遍历完毕，若不为空，则将遍历指针移动到next指向的结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LinkList::Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">IsEmpty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;This List is empty&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">pnode pn;</span><br><span class="line">pn=head-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(pn!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">pn=pn-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h3><p>判空函数十分简单，直接上代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Boolean <span class="title">LinkList::IsEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(size==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查-1"><a href="#查-1" class="headerlink" title="查"></a>查</h3><p>查找操作一共分为两种，按值查找（Locate）和按位查找（Get）</p><ol><li><p><strong>按值查找</strong></p><p>按值查找就是给定一个值去查找它在链表中的位置，实现方式也是从头结点<code>head</code>开始逐一对比，找到即返回位置</p><p>由于需要逐一对比，所以在等概率的情况下，平均时间性能为<code>O(n)</code></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LinkList::Locate</span><span class="params">(DataType ele)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">IsEmpty</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Error :This List is empty!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">  pnode inode;</span><br><span class="line">  inode=head;</span><br><span class="line">  <span class="keyword">while</span>(inode!=<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(index!=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span>(inode-&gt;data==ele)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;index:&quot;</span>&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    inode=inode-&gt;next;</span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;The number is not in this list!&quot;</span>&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//未搜到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>按位查找</strong><br>按位查找就是给定一个位置，然后对链表进行遍历，找到对应位置的元素返回即可</p><p>若查找位置位<code>i</code>则需要执行对比<code>i-1</code>次，等概率情况下，平均时间性能为<code>O(n)</code>，因此单链表是<strong>顺序存取</strong></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DataType <span class="title">LinkList::Get</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">IsEmpty</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Error :This List is empty!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    p = head-&gt;next;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; count &lt; i) &#123;</span><br><span class="line">        p = p-&gt; next;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;位置错误&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p -&gt; data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>链表的插入操作相对于顺序表要容易很多，因为是链式结构只需要处理相邻元素即可，不会影响整个线性表，这也是链表相对顺序表最大的优点之处</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Boolean <span class="title">LinkList::Insert</span><span class="params">(DataType ele,<span class="type">int</span> loc)</span> <span class="comment">//数据、插入位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(loc &lt; <span class="number">0</span> || loc &gt; size) <span class="comment">//判断位置是否合法</span></span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Location is invalid.&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> i,index=<span class="number">0</span>;</span><br><span class="line">pnode inode,snode,erg;</span><br><span class="line">snode=<span class="keyword">new</span> node;</span><br><span class="line">snode-&gt;data=ele;</span><br><span class="line">inode=head;</span><br><span class="line">erg=head;</span><br><span class="line"><span class="keyword">if</span>(loc==size)<span class="comment">//插入位置在结尾位置</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(inode-&gt;next!=<span class="literal">NULL</span>) </span><br><span class="line">&#123;</span><br><span class="line">inode=inode-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">snode-&gt;next=inode-&gt;next;</span><br><span class="line">inode-&gt;next=snode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//插入位置非结尾位置</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=loc;i++) <span class="comment">//搜寻指定位置</span></span><br><span class="line">&#123;</span><br><span class="line">inode=inode-&gt;next; <span class="comment">//head -&gt; next</span></span><br><span class="line"><span class="keyword">if</span>(i!=<span class="number">0</span>)<span class="comment">//错位，erg需要在inode前一个结点</span></span><br><span class="line">erg=erg-&gt;next; <span class="comment">//head -&gt;next</span></span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line">snode-&gt;next=inode;  <span class="comment">//插入操作</span></span><br><span class="line">erg-&gt;next=snode;</span><br><span class="line">&#125;</span><br><span class="line">size++; <span class="comment">//插入后修改size</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除操作的主要时耗也是在查找正确的删除位置上，因此时间复杂度为<code>O(n)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Boolean <span class="title">Linear::Del</span><span class="params">(DataType ele)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pnode inode,snode;</span><br><span class="line"><span class="type">int</span> i,loc=<span class="number">0</span>;</span><br><span class="line">inode=head;</span><br><span class="line">loc=<span class="built_in">Search</span>(ele);</span><br><span class="line"><span class="keyword">if</span>(loc==<span class="number">-2</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(loc==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;CON&#x27;T DELETE : This number is not in this list!&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i<span class="number">-1</span>;i++) <span class="comment">//查找需要删除结点位置</span></span><br><span class="line">&#123;</span><br><span class="line">inode=inode-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(loc==size) <span class="comment">// 如果要删除的结点在尾部</span></span><br><span class="line">&#123;</span><br><span class="line">snode=inode-&gt;next;</span><br><span class="line">inode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">delete</span> snode; <span class="comment">//释放空间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">snode=inode-&gt;next;</span><br><span class="line">inode-&gt;next=snode-&gt;next; <span class="comment">//跳过snode指向的结点，将inode指向inode的下下个结点</span></span><br><span class="line"><span class="keyword">delete</span> snode;<span class="comment">//释放空间</span></span><br><span class="line">&#125;</span><br><span class="line">size--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><blockquote><p>循环链表的原理其实就是没有尾结点，将逻辑上的尾结点的next指针直接指向head头结点，形成逻辑循环链表</p></blockquote><p><img src="https://s1.ax1x.com/2020/08/03/ad3d2R.png"></p><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>双链表与单链表的区别就是结点除了有用指向后继结点的next以外，还会存在prior的指向前置结点的指针</p><ul><li>data是数据域，用于存放数据</li><li>prior是前驱指针域，存放该结点的前驱结点地址</li><li>next是后继指针域，存放该结点的后继结点地址<br><img src="https://s1.ax1x.com/2020/08/03/ad8Uw8.png"></li></ul><p>对于所有的操作都必须考虑前驱节点和后继节点，对他们共同操作！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>链表是最重要的数据结构基础，上面是我根据过往学习资料整理出来的一些知识点，希望能对未来有所帮助！！</p><h2 id="阶段总结"><a href="#阶段总结" class="headerlink" title="阶段总结"></a>阶段总结</h2><p>数据结构的知识点是我一直以来都想总结的，也是未来必须需要的，文笔还是需要改进，代码还算是原创，是仿照之前的代码慢慢写出来的，整整两天时间，最终写完还算心情舒畅吧，马上就要启程去实习了，为了未来，加油！！！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue学习笔记 — 模板编译原理</title>
      <link href="/2020/07/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E2%80%94-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
      <url>/2020/07/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E2%80%94-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue学习笔记-—-模板编译原理"><a href="#Vue学习笔记-—-模板编译原理" class="headerlink" title="Vue学习笔记 — 模板编译原理"></a>Vue学习笔记 — 模板编译原理</h1><p>Vue.js提供了模板语法，允许我们声明式地描述状态和DOM之间地绑定关系，然后通过模板来生成真实DOM并将其呈现在用户界面上</p><h2 id="渲染步骤"><a href="#渲染步骤" class="headerlink" title="渲染步骤"></a>渲染步骤</h2><p>将模板编译成渲染函数可以分为两个步骤，先将模板解析成**AST(Abstract Syntax Tree，抽象语法树)**，然后再使用AST生成渲染函数</p><p>由于静态节点不需要总是重新渲染，因此在生成AST之后与生成渲染函数之前会需要一个操作-&gt;遍历一遍AST，给所有静态节点做一个标记，这样在虚拟DOM更新节点时就会发现这个标记，也就不会重新渲染它</p><p>模板编译答题分为三个部分：</p><ul><li>将模板解析为AST</li><li>遍历AST标记静态节点</li><li>使用AST生成渲染函数</li></ul><p>这三个部分在模板编译中分别抽象出三个模块来实现功能：</p><ul><li>解析器</li><li>优化器</li><li>代码生成器</li></ul><h2 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h2><p>解析器地功能就是将模板解析为AST</p><p>在解析器内部，分成了很多小的解析器-&gt;过滤器解析器，文本解析器、HTML解析器，通过主线将这些解析器组装在一起</p><p>文本解析器主要用于解析带有变量的文本<code>Hello</code>，不带有变量的文本是不需要使用文本解析器进行解析的</p><p>解析器的内部其实页分为了好几种解析器，有HTML解析器、文本解析器、以及过滤器解析器等其中最重要的就是HTML解析器，它在解析HTML的过程中会触发各种钩子函数，其中包括有开始标签钩子函数、结束标签钩子函数、文本钩子函数以及注释钩子函数</p><p>以下是相关的伪代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">parseHTML</span>(template, &#123;</span><br><span class="line">    <span class="title function_">start</span>(<span class="params">tag, attrs, unary</span>) &#123; <span class="comment">//标签名， 标签的属性， 是否是自闭合函数</span></span><br><span class="line">        <span class="comment">// 每当解析到标签开始位置时，触发该函数</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">end</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 每当解析到标签结束位置时，触发该函数</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">chars</span>(<span class="params">text</span>) &#123;</span><br><span class="line">        <span class="comment">// 每当解析到文本时，触发该函数</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">comment</span>(<span class="params">text</span>) &#123;</span><br><span class="line">        <span class="comment">// 每当解析到注释时，触发该函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当HTML解析器进行解析时会依次触发这些钩子函数，注意：哪怕是仅含有空格，也会触发start钩子函数</p><p>在parseHTML()函数中会循环对模板进行解析，每一轮循环中，都会进行字符串的截取，被截取的片段会分很多类型：</p><p>开始标签、结束标签、HTML注释、DOCTYPE，条件注释、文本</p><h3 id="截取开始标签"><a href="#截取开始标签" class="headerlink" title="截取开始标签"></a>截取开始标签</h3><p>在HTML解析器中，想分辨模板是否以开始标签开头不难，应该先判断是否以 &lt; 开头， 如果不是，那么它一定不是以开始标签开头的模板，也就不需要执行开始标签的截取操作， 如果是以<code>&lt;</code>开头的，那么就需要对其具体的标签类型进行解析判断，这也就需要开始使用正则表达式进行解析了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ncname = <span class="string">`[a-zA-z_][\\w\\-\\.]*`</span></span><br><span class="line"><span class="keyword">const</span> qnameCapture = <span class="string">`((?:<span class="subst">$&#123;ncname&#125;</span>\\:)?<span class="subst">$&#123;ncname&#125;</span>)`</span></span><br><span class="line"><span class="keyword">const</span> startTagOpen = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">`^&lt;<span class="subst">$&#123;qnameCapture&#125;</span>`</span>)</span><br></pre></td></tr></table></figure><p>对开始标签进行截取后，会通过正则表达式进行分析，开始标签的解析中需要判断是否为自闭合标签，例如<code>&lt;input/&gt;</code>就是自闭合标签，我们需要使用循环递归的方式解析标签中所携带的属性，并构建生成AST，之后我们需要根据标签的类型来进行下一步的解析，有如下几种情况：</p><ul><li>文本</li><li>注释</li><li>条件注释</li><li>DOCTYPE</li><li>结束标签</li><li>开始标签</li></ul><p>我们使用栈维护DOM的层级，以便于更加清晰地知道节点之间的父子关系</p><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><p>上面这些情况中最特殊的就是文本，文本的解析不需要正则表达式的参与，因为我们都知道从<strong>开始标签的结束</strong>到<strong>结束标签的开始</strong>这之间存在的就是文本，所以我们解析时只需要对去除开始标签后的整体使用<code>indexof(&#39;&lt;&#39;)</code>找到结束标签的开始位置，截取其之前的所有字符就是文本</p><p>为什么说文本特殊，因为文本本身就有两种，一种使 纯文本，而另一种则是携带有变量的文本，如果是纯文本则不需要进行热河处理，但是如果是携带变量的文本，则我们需要使用文本解析器进行更进一步的解析，因为携带变量的文本在我们使用虚拟DOM进行渲染时需要将文本中的变量替换为变量所代表的值</p><p>当<code>&quot;Hello &quot;</code>被解析时</p><p>这是一个携带变量的文本，触发chars函数后，</p><p>会得到一个这样的expression变量<code>&quot;Hello &quot; + _s(name)</code></p><p><code>_s</code>就是<code>toString()</code>的别名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toString</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> val == <span class="literal">null</span></span><br><span class="line">      ? <span class="string">&#x27;&#x27;</span></span><br><span class="line">      : <span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span></span><br><span class="line">      ? <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(val, <span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line">      : <span class="title class_">String</span>(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在文本解析器中第一步就是对使用正则表达式对文本进行解析，也就是判断是不是纯文本，如果携带变量那么就会进行二次加工，将变量加载在文本中。</p><p>解析器的作用就是通过模板得到AST（抽象语法树）</p><p>生长城AST的过程需要借助HTMLi基尔希奇，当解析器触发不同的钩子函数时，可以构建出不同的节点，随后可以通过栈来确立他们之间的层级关系，最后我们可以得到一个完整的带DOM层级关系的AST</p><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>优化器的目标是遍历AST，检测出所有静态子树，并为其添加标记</p><p>优化器的主要功能就是避免一些无用功来提升性能</p><h3 id="什么是静态子树"><a href="#什么是静态子树" class="headerlink" title="什么是静态子树"></a>什么是静态子树</h3><p>静态子树就是指 那些在AST中永远不会发生改变的节点，例如一个不带有任何变量的纯文本节点就是一个静态子树，而一个带有变量的文本就不是，因为他的内容会随着变量的更改而更改</p><p>标记静态子树的好处：</p><ul><li>每次重新渲染的时候，不需要为静态子树创建新的节点</li><li>在虚拟DOM中打补丁(patching)的过程中可以跳过</li></ul><p>以上两点好处能够有效节省JavaScript的运算成本</p><p><strong>优化器内部对的主要步骤：</strong></p><ol><li>在AST中找出所有的静态节点并打标记</li><li>在AST中赵出所有的静态根节点并打上标记</li></ol><p><strong>静态根节点：</strong> 如果一个节点下面的所有子节点都是静态节点，它的父级是动态节点，那么它就是静态根节点</p><h3 id="静态节点与静态根节点在AST中的表示"><a href="#静态节点与静态根节点在AST中的表示" class="headerlink" title="静态节点与静态根节点在AST中的表示"></a>静态节点与静态根节点在AST中的表示</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//静态节点</span><br><span class="line">/*</span><br><span class="line">我是静态节点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">//AST表示</span><br><span class="line">&#123;</span><br><span class="line">    type: 1,</span><br><span class="line">    tag: &#x27;p&#x27;,</span><br><span class="line">    staticRoot: false,</span><br><span class="line">    static: true,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//静态根节点</span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">我是静态节点1</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">我是静态节点2</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">我是静态节点3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//AST表示</span><br><span class="line">&#123;</span><br><span class="line">type: 1,</span><br><span class="line">tag: &#x27;ul&#x27;</span><br><span class="line">staticRoot: true,</span><br><span class="line">static: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的AST节点经过优化器处理后，都会添加<code>static</code>属性和<code>staticRoot</code>属性，而优化器也正是通过这两个属性来对静态节点和静态根节点进行标记的</p><h3 id="找出并标记静态节点"><a href="#找出并标记静态节点" class="headerlink" title="找出并标记静态节点"></a>找出并标记静态节点</h3><p>基本操作就是从根节点开始向内层循环，判断根节点是不是静态节点，再用相同的方式处理子节点，直到所有子节点都处理完毕，就退出循环</p><p>节点标记函数就是首先通过<code>isStatic</code>函数对节点是否是静态节点进行判断，然后根据判断结果对static属性进行修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">markStatic</span> (node) &#123;</span><br><span class="line">    node.<span class="property">static</span> = <span class="title function_">isStatic</span>(node)</span><br><span class="line">    <span class="keyword">if</span>(node.<span class="property">type</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = node.<span class="property">children</span>.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="title function_">markStatic</span>(child)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!child.<span class="property">static</span>) &#123; <span class="comment">//防止出现父节点被标记静态而子节点为动态节点</span></span><br><span class="line">            node.<span class="property">static</span> = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面提到并且调用了<code>isStatic</code>函数，它在源码中的实现是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isStatic</span> (node) &#123;</span><br><span class="line">    <span class="keyword">if</span>(node.<span class="property">type</span> === <span class="number">2</span>) &#123; <span class="comment">//带有变量的文本节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ndoe.<span class="property">type</span> === <span class="number">3</span>) &#123; <span class="comment">//不带变量的纯文本节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !!(node.<span class="property">pre</span> || (</span><br><span class="line">        !node.<span class="property">hasBindings</span> &amp;&amp; <span class="comment">//没有动态绑定</span></span><br><span class="line">        !node.<span class="property">is</span> &amp;&amp; !node.<span class="property">for</span> &amp;&amp; <span class="comment">//没有v-if和v-for</span></span><br><span class="line">        !<span class="title function_">isBuiltInTag</span>(node.<span class="property">tag</span>) &amp;&amp;<span class="comment">//不是内置标签</span></span><br><span class="line">        <span class="title function_">isPlatformReservedTag</span>(node.<span class="property">tag</span>) &amp;&amp;<span class="comment">//不是组件</span></span><br><span class="line">        !<span class="title function_">isDirectChildOfTemplateFor</span>(node) &amp;&amp;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">keys</span>(ndoe).<span class="title function_">every</span>(isStaticKey)</span><br><span class="line">    ))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>符合静态节点的条件也十分苛刻：</p><ul><li>不能使用动态绑定语法，也就是标签中不能有<code>v-</code>, <code>@</code>, <code>:</code>，开头的属性</li><li>不能使用<code>v-if</code>,<code>v-for</code>或<code>v-else</code>等指令</li><li>不能是内置标签，即<code>slot</code>、<code>component</code>等</li><li>不能使组件，即标签名必须是保留标签</li><li>当前节点的父节点不能是带有<code>v-for</code>指令的<code>template</code>标签</li><li>节点中不存在动态节点才会有的属性（静态节点的属性范围：<code>type</code>、<code>tag</code>、<code>attrsList</code>、<code>attrMap</code>、<code>plain</code>、<code>parent</code>、<code>children</code>、<code>attrs</code>、<code>staticClass</code>和<code>staticStyle</code>）</li></ul><h3 id="找出并标记所有静态根节点"><a href="#找出并标记所有静态根节点" class="headerlink" title="找出并标记所有静态根节点"></a>找出并标记所有静态根节点</h3><p>这个过程与上面标记静态节点的过程类似，不同的就是静态根节点的寻找过程中，如果我们确定了静态根节点，那么我们就没有继续向下寻找了</p><p>我们上面的代码中提到过这样一个逻辑，静态节点的所有子节点也都是静态节点，所以我们在遍历时所见到的第一个静态节点肯定是静态根节点，它所有的子节点也肯定是静态节点</p><p><strong><font color="red">！！！注意：有一种例外情况就是当一个节点没有任何子节点，知识独立的静态节点时，它是静态根节点，但是不需要标记为静态根节点，因为完全没有必要，优化的成本反而更高</font></strong></p><h2 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h2><p>代码生成器是模板编译的 最后一步，它的作用是将AST转换成渲染函数中的内容，这个内容称为”代码字符串“</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码丢失</span></span><br></pre></td></tr></table></figure><p>生成的代码为：<br><code>with(this)&#123;return _c(&#39;p&#39;,&#123;attrs:&#123;&quot;title&quot;:&quot;Sleepygod&quot;&#125;,on:&#123;&quot;click&quot;:c&#125;&#125;,[_v(&quot;1&quot;)])&#125;</code><br>格式化后是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (<span class="variable language_">this</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">_c</span>(</span><br><span class="line">        <span class="string">&quot;div&quot;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">attrs</span>: &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;el&quot;</span>&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        [</span><br><span class="line">            <span class="title function_">_v</span>(<span class="string">&quot;Hello &quot;</span> + <span class="title function_">_s</span>(name))</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样将一个代码字符串导出到外界使用时，会将代码字符串放到函数中，这个函数叫做渲染函数</p><p>渲染函数的作用是创建<code>vnode</code>，代码字符串中的<code>_c</code>与<code>_v</code>都是创建<code>vnode</code>的方法，<code>_c</code>是创建<code>元素类型的vnode</code>，<code>_v</code>是创建<code>文本类型的vnode</code></p><p><code>_c</code>就是<code>createElement</code>的别称，它是虚拟DOM中提供的方法，他的作用是创建虚拟节点</p><h3 id="通过AST生成代码字符串"><a href="#通过AST生成代码字符串" class="headerlink" title="通过AST生成代码字符串"></a>通过AST生成代码字符串</h3><p>节点共有三种类型：元素节点、文本节点、注释节点</p><p>对应的创建方法： <code>createElement</code>、<code>createTextVNode</code>、<code>createEmptyVNode</code></p><p>对应的别名：<code>_c</code>、<code>_v</code>、<code>_e</code></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>不同类型的节点生成方式是不一样的</p><h4 id="元素节点"><a href="#元素节点" class="headerlink" title="元素节点"></a>元素节点</h4><p>生成元素节点，其实就是生成一个<code>_c</code>的函数调用字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getElement</span> (el, state) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = el.<span class="property">plain</span> ? <span class="literal">undefined</span> : <span class="title function_">getData</span>(el, state)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> children = <span class="title function_">genChilderen</span>(el, state)</span><br><span class="line">    code = <span class="string">`_c(&#x27;<span class="subst">$&#123;el.tag&#125;</span>&#x27;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;data ? <span class="string">`<span class="subst">$&#123;data&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>&#125;</span></span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;children ? <span class="string">`,<span class="subst">$&#123;children&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>&#125;</span></span></span><br><span class="line"><span class="string">    )`</span></span><br><span class="line">    <span class="keyword">return</span> code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>plain属性是在编译的时候发现的，如果节点没有属性，就会把plain设置为<code>true</code></p><p>代码中的主要逻就是通过<code>getData</code>和<code>getChildren</code>分别获取<code>data</code>和<code>children</code>，然后将他们拼接到字符串指定的位置，最后把拼好的<code>_c(tagName, data, children)</code>返回，这样一个元素节点的代码字符串就生成好了</p><p>而data与children也是字符串，他们的生成方式就是先给data赋值<code>&#39;&#123;&#39;</code>然后发现节点中有哪些属性数据，就将他们直接拼接在data中，最后拼接一个<code>&#39;&#125;&#39;</code>这样data就生成好了</p><h4 id="文本节点"><a href="#文本节点" class="headerlink" title="文本节点"></a>文本节点</h4><p>文本节点的生成依旧非常简单，我们只需要将文本放在<code>_v</code>这个函数的参数中即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getText</span> (text) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`_v(<span class="subst">$&#123;text.type === <span class="number">2</span></span></span></span><br><span class="line"><span class="subst"><span class="string">  ? text.expression</span></span></span><br><span class="line"><span class="subst"><span class="string">      : <span class="built_in">JSON</span>.stringify(text.text)</span></span></span><br><span class="line"><span class="subst"><span class="string">&#125;</span>)`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会判断文本的类型，如果是动态文本就使用<code>expression</code>，如果是静态文本，就使用<code>text</code></p><h4 id="注释节点"><a href="#注释节点" class="headerlink" title="注释节点"></a>注释节点</h4><p>注释节点的生成方式与文本节点相似</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getComment</span> (comment) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`_e(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(comment.text)&#125;</span>)`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>模板编译是Vue最重要的一部分，先由解析器进行代码解析，生成AST，再由优化器对AST进行优化，将所有静态节点和静态根节点惊醒标记，然后由代码生成器生成渲染函数所需要的渲染字符串，最后交给虚拟DOM的渲染函数进行渲染操作。</p><h2 id="近期总结"><a href="#近期总结" class="headerlink" title="近期总结"></a>近期总结</h2><p>前前后后总共学习了5、6天左右的时间，中间也经历了几次面试，之后可能会更新面试经历吧，还没有面试成功，还没有找到实习，直接开始准备秋招了，加油加油！！！</p>]]></content>
      
      
      <categories>
          
          <category> Vue学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue2 </tag>
            
            <tag> Vue原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue学习笔记 — 虚拟DOM</title>
      <link href="/2020/06/04/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E2%80%94-%E8%99%9A%E6%8B%9FDOM/"/>
      <url>/2020/06/04/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E2%80%94-%E8%99%9A%E6%8B%9FDOM/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue学习笔记-—-虚拟DOM"><a href="#Vue学习笔记-—-虚拟DOM" class="headerlink" title="Vue学习笔记 —- 虚拟DOM"></a>Vue学习笔记 —- 虚拟DOM</h1><h2 id="什么是虚拟DOM"><a href="#什么是虚拟DOM" class="headerlink" title="什么是虚拟DOM"></a>什么是虚拟DOM</h2><p>随着时代的发展，页面上的功能越来越多，程序中需要维护的状态越来越多，DOM操作也越来越频繁</p><p>我们发现像之前那样使用jQuery或原生js来开发页面，那么操作DOM的代码占据大多数，程序中的状态也难以进行管理，这被称为<strong>命令式操作DOM</strong>，虽然简单实用，但是却难以进行维护。</p><p>当我们开始使用三大主流框架Vue.js、Angular和React时，他们都是声明式地操作DOM，我们通过描述状态与DOM之间的映射关系，就可以将状态转换为视图，甚至我们根本不需要手动操作DOM</p><p><font color="red">我们的关注点应该聚焦在状态维护上，而DOM操作其实是可以省略的</font></p><p>当某个状态发生改变时，只更新与它相关的DOM节点，为了解决这个问题，主流框架都有着自己的一套解决方案，Angular中使用脏检查的流程，React中使用的是虚拟DOM，Vue1.0使用细粒度的绑定</p><p>虚拟DOM的解决方式是通过状态生成一个虚拟节点树，然后使用虚拟节点树进行渲染，渲染之间会将新旧虚拟节点树进行对比，只渲染不一样的地方</p><p>使用虚拟节点进行DOM操作有效提高了性能</p><p>虚拟DOM在Vue.js中只做了两件事：</p><ul><li>提供与真实DOM节点对应的虚拟节点<strong>vnode</strong></li><li>将虚拟节点<strong>vnode</strong>与旧虚拟节点<strong>oldVnode</strong>进行对比，然后进行视图更新</li></ul><p>两个虚拟节点进行对比是虚拟DOM中最核心的算法<code>patch</code>，它可以判断出哪些节点发生了变化，从而进行节点更新操作</p><h2 id="VNode"><a href="#VNode" class="headerlink" title="VNode"></a>VNode</h2><p>Vue.js中存在一个<strong>VNode</strong>类，可以用来实例化不同类型的vnode实例，而不同类型的vnode实例各自代表着不同的DOM元素</p><p>先来看一下VNode的定义源码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">VNode</span> &#123;</span><br><span class="line">  <span class="attr">tag</span>: string | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">data</span>: <span class="title class_">VNodeData</span> | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">children</span>: ?<span class="title class_">Array</span>;</span><br><span class="line">  <span class="attr">text</span>: string | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">elm</span>: <span class="title class_">Node</span> | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">ns</span>: string | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">context</span>: <span class="title class_">Component</span> | <span class="keyword">void</span>; <span class="comment">// rendered in this component&#x27;s scope</span></span><br><span class="line">  <span class="attr">key</span>: string | number | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">componentOptions</span>: <span class="title class_">VNodeComponentOptions</span> | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">componentInstance</span>: <span class="title class_">Component</span> | <span class="keyword">void</span>; <span class="comment">// component instance</span></span><br><span class="line">  <span class="attr">parent</span>: <span class="title class_">VNode</span> | <span class="keyword">void</span>; <span class="comment">// component placeholder node</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// strictly internal</span></span><br><span class="line">  <span class="attr">raw</span>: boolean; <span class="comment">// contains raw HTML? (server only)</span></span><br><span class="line">  <span class="attr">isStatic</span>: boolean; <span class="comment">// hoisted static node</span></span><br><span class="line">  <span class="attr">isRootInsert</span>: boolean; <span class="comment">// necessary for enter transition check</span></span><br><span class="line">  <span class="attr">isComment</span>: boolean; <span class="comment">// empty comment placeholder?</span></span><br><span class="line">  <span class="attr">isCloned</span>: boolean; <span class="comment">// is a cloned node?</span></span><br><span class="line">  <span class="attr">isOnce</span>: boolean; <span class="comment">// is a v-once node?</span></span><br><span class="line">  <span class="attr">asyncFactory</span>: <span class="title class_">Function</span> | <span class="keyword">void</span>; <span class="comment">// async component factory function</span></span><br><span class="line">  <span class="attr">asyncMeta</span>: <span class="title class_">Object</span> | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">isAsyncPlaceholder</span>: boolean;</span><br><span class="line">  <span class="attr">ssrContext</span>: <span class="title class_">Object</span> | <span class="keyword">void</span>;</span><br><span class="line">  <span class="attr">fnContext</span>: <span class="title class_">Component</span> | <span class="keyword">void</span>; <span class="comment">// real context vm for functional nodes</span></span><br><span class="line">  <span class="attr">fnOptions</span>: ?<span class="title class_">ComponentOptions</span>; <span class="comment">// for SSR caching</span></span><br><span class="line">  <span class="attr">devtoolsMeta</span>: ?<span class="title class_">Object</span>; <span class="comment">// used to store functional render context for devtools</span></span><br><span class="line">  <span class="attr">fnScopeId</span>: ?string; <span class="comment">// functional scope id support</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span> (</span><br><span class="line">    tag?: string,</span><br><span class="line">    data?: <span class="title class_">VNodeData</span>,</span><br><span class="line">    children?: ?<span class="title class_">Array</span>,</span><br><span class="line">    text?: string,</span><br><span class="line">    elm?: <span class="title class_">Node</span>,</span><br><span class="line">    context?: <span class="title class_">Component</span>,</span><br><span class="line">    componentOptions?: <span class="title class_">VNodeComponentOptions</span>,</span><br><span class="line">    asyncFactory?: <span class="title class_">Function</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tag</span> = tag</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span> = data</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">children</span> = children</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">text</span> = text</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">elm</span> = elm</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ns</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">context</span> = context</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fnContext</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fnOptions</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fnScopeId</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = data &amp;&amp; data.<span class="property">key</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">componentOptions</span> = componentOptions</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">componentInstance</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">parent</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">raw</span> = <span class="literal">false</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isStatic</span> = <span class="literal">false</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isRootInsert</span> = <span class="literal">true</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isComment</span> = <span class="literal">false</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isCloned</span> = <span class="literal">false</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isOnce</span> = <span class="literal">false</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">asyncFactory</span> = asyncFactory</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">asyncMeta</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isAsyncPlaceholder</span> = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// DEPRECATED: alias for componentInstance for backwards compat.</span></span><br><span class="line">  <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">  get child (): <span class="title class_">Component</span> | <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">componentInstance</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vnode可以理解为<strong>节点描述对象</strong>，它描述了应该怎样去创建一个真实的DOM节点，例如：tag表示节点的名称，text表示文本节点的文本，children表示子节点~</p><p>vnode代表的是一个真实的DOM元素，所有的真实DOM节点都使用vnode创建并插入到页面中。</p><p>在vue.js中会对vnode进行缓存，当有新的vnode时会与旧的vnode进行对比，只更新发生变化的节点，以节省性能，这是vnode最重要的一个作用</p><p>vnode的类型有以下几种：</p><ul><li>注释节点</li><li>文本节点</li><li>元素节点</li><li>组件节点</li><li>函数式组件</li><li>克隆节点</li></ul><h3 id="注释节点"><a href="#注释节点" class="headerlink" title="注释节点"></a>注释节点</h3><p>创建注释节点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">createEmptyVNode</span> = (<span class="params">text: string = <span class="string">&#x27;&#x27;</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">new</span> <span class="title class_">VNode</span>()</span><br><span class="line">  node.<span class="property">text</span> = text</span><br><span class="line">  node.<span class="property">isComment</span> = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释节点只有两个有效属性： <code>text</code>、<code>isComment</code>对应<code>vnode</code>应该是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">text</span>: <span class="string">&#x27;注释节点&#x27;</span>,</span><br><span class="line">    <span class="attr">isComment</span>: <span class="string">&#x27;true&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文本节点"><a href="#文本节点" class="headerlink" title="文本节点"></a>文本节点</h3><p>创建过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createTextVNode</span> (<span class="attr">val</span>: string | number) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">VNode</span>(<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="title class_">String</span>(val))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文本节点被创建时只有一个text属性，因此对应vnode应该是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">text</span>: <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="克隆节点"><a href="#克隆节点" class="headerlink" title="克隆节点"></a>克隆节点</h3><p>克隆节点是将现有节点的属性复制到新的节点中，让新创建的节点属性与克隆节点保持一致实现克隆效果。</p><p>克隆节点的作用是优化静态节点和插槽节点（slot node）</p><p>以静态节点为例，当组件内的某个状态发生改变时，当前组件会通过虚拟DOM重新渲染视图，静态节点因为他的内容不会改变，所以除了首次渲染外其他时候都不需要重新生成新的vnode，此时使用创建克隆节点的方法将vnode进行克隆，使用克隆节点进行渲染，这样就不需要重新执行渲染函数生成新的静态节点，也就提升了一定程度的性能</p><p>克隆节点的创建过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">cloneVNode</span> (<span class="attr">vnode</span>: <span class="title class_">VNode</span>): <span class="title class_">VNode</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> cloned = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">    vnode.<span class="property">tag</span>,</span><br><span class="line">    vnode.<span class="property">data</span>,</span><br><span class="line">    <span class="comment">// #7975</span></span><br><span class="line">    <span class="comment">// clone children array to avoid mutating original in case of cloning</span></span><br><span class="line">    <span class="comment">// a child.</span></span><br><span class="line">    vnode.<span class="property">children</span> &amp;&amp; vnode.<span class="property">children</span>.<span class="title function_">slice</span>(),</span><br><span class="line">    vnode.<span class="property">text</span>,</span><br><span class="line">    vnode.<span class="property">elm</span>,</span><br><span class="line">    vnode.<span class="property">context</span>,</span><br><span class="line">    vnode.<span class="property">componentOptions</span>,</span><br><span class="line">    vnode.<span class="property">asyncFactory</span></span><br><span class="line">  )</span><br><span class="line">  cloned.<span class="property">ns</span> = vnode.<span class="property">ns</span></span><br><span class="line">  cloned.<span class="property">isStatic</span> = vnode.<span class="property">isStatic</span></span><br><span class="line">  cloned.<span class="property">key</span> = vnode.<span class="property">key</span></span><br><span class="line">  cloned.<span class="property">isComment</span> = vnode.<span class="property">isComment</span></span><br><span class="line">  cloned.<span class="property">fnContext</span> = vnode.<span class="property">fnContext</span></span><br><span class="line">  cloned.<span class="property">fnOptions</span> = vnode.<span class="property">fnOptions</span></span><br><span class="line">  cloned.<span class="property">fnScopeId</span> = vnode.<span class="property">fnScopeId</span></span><br><span class="line">  cloned.<span class="property">asyncMeta</span> = vnode.<span class="property">asyncMeta</span></span><br><span class="line">  cloned.<span class="property">isCloned</span> = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> cloned</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码可以看出，创建克隆节点时只需要将现有节点的全部属性复制到新节点中即可，与源节点的区别是克隆节点的<code>isCloned</code>属性为<code>true</code></p><h3 id="元素节点"><a href="#元素节点" class="headerlink" title="元素节点"></a>元素节点</h3><p>元素节点存在四个属性：</p><ul><li>tag：如p, ul, li, div等</li><li>data：节点上的数据如：attrs、class、style等</li><li>children：当前节点的子节点列表</li><li>context：当前组件的vue.js实例</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>aaaspan<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>bbbspan<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是一个真实的元素节点<br>对应Vnode应该时这样的：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    children: [VNode, VNode],</span><br><span class="line">    contextL: &#123;...&#125;,</span><br><span class="line">    data: &#123;...&#125;,</span><br><span class="line">    tag: &quot;p&quot;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组件节点"><a href="#组件节点" class="headerlink" title="组件节点"></a>组件节点</h3><p>组件节点与元素节点类似，它有两个独特的属性</p><ul><li><strong>componentOptions：</strong> 组件节点的选项参数，其中包含<code>propData</code>、<code>tag</code>、<code>children</code>等</li><li><strong>componentInstance：</strong> 组件的实例，也是Vue的实例，在Vue.js中每一个组件都是一个Vue实例</li></ul><h3 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h3><p>函数式组件与组件节点类似，它独有的属性是：<code>functionalContext</code>和<code>functionalOptions</code></p><h2 id="patch算法"><a href="#patch算法" class="headerlink" title="patch算法"></a>patch算法</h2><p>虚拟DOM最核心的部分就是<strong>patch</strong>，它可以将vnode渲染成真实的DOM</p><p>patch也被称为<strong>pathching</strong>算法，在对真实DOM进行渲染时，它会对比新旧vnode有什么不同，然后根据对比结果找出需要更新的节点</p><p>patch不是暴力替换节点，而是在现在DOM上进行修改来达到渲染视图的目的，渲染的过程基本如下：</p><ul><li>创建新增的节点</li><li>删除已经废弃的节点</li><li>修改需要更新的节点</li></ul><h3 id="新增节点"><a href="#新增节点" class="headerlink" title="新增节点"></a>新增节点</h3><p>首次渲染时（此时页面内部没有节点，不存在<code>oldVnode</code>），我们面临的是不存在<code>oldVnode</code>的情况，这是我们只需要使用<code>vnode</code>直接创建元素并渲染视图就可以了</p><p>而当<code>vnode</code>被创建后，<code>oldVnode</code>存在且与<code>vnode</code>完全不一样的时候，会以<code>vnode</code>为标准来进行视图渲染，此时<code>vnode</code>是一个全新的节点，而<code>oldVnode</code>是一个被废弃的节点，</p><p>这时我们需要的就是使用<code>vnode</code>创建一个新的DOM节点，用这个节点去替换<code>oldVnode</code>所对应的节点</p><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><p>事实上只有三种类型的节点会被创建并插入到DOM中：元素机欸但、注释节点和文本节点</p><p>要判断<code>vnode</code>是否是元素节点，只需要判断它是否拥有tag属性，如果一个<code>vnode</code>拥有<code>itag</code>属性，那么就认为他是元素节点，这时就会调用当前环境下的<code>createElement</code>（浏览器中时调用<code>document.createElement</code>）来创建真实的元素节点，元素节点被创建后，需要将它渲染到视图中</p><p>这个渲染过程也是比较简单的，只需要调用当前环境下的<code>appendChild</code>（浏览器中调用<code>parentNode.appendChild</code>）就可以将一个元素节点插入到指定的父节点中，如果这个父节点已经被渲染到视图中，那么元素节点插入后会被自动渲染</p><p>其实创建节点的过程中还需要创建他的子节点，子节点的创建过程是一个递归过程，vnode中的children属性保存了当前节点的所有子虚拟节点（child virtual node）对children递归创建，对每一个子节点都执行一遍创建节点的过程，这样就会渲染出一个完整的DOM结构</p><p>除去元素节点外，还有注释节点和文本节点需要创建，注释节点的特性就是属性isComment为true，所以通过对这个属性的判断旧可以判断vnode是不是一个注释节点，如果是一个注释节点，就会调用当前环境下的<code>createComment</code>（浏览器下<code>document.createComment</code>）来创建真实的注释节点并插入到指定父节点中</p><p>如果是文本节点，就会调用当前环境的<code>createTextNode</code>方法（浏览器下<code>document.createTextNode</code>）来创建真实的文本节点并将其加入到指定的父节点中</p><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>在新增节点中提到过，当有一个vnode对oldVnode进行替换时根据vnode创建的新节点插入到就节点的旁边，然后oldValue对应的旧节点会被删除，这样就完成了替换的过程</p><p>源码中是这么写的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">removeVnodes</span> (vnodes, startIdx, endIdx) &#123;</span><br><span class="line">   <span class="keyword">for</span> (; startIdx &lt;= endIdx; ++startIdx) &#123;</span><br><span class="line">     <span class="keyword">const</span> ch = vnodes[startIdx]</span><br><span class="line">     <span class="keyword">if</span> (<span class="title function_">isDef</span>(ch)) &#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="title function_">isDef</span>(ch.<span class="property">tag</span>)) &#123;</span><br><span class="line">         <span class="title function_">removeAndInvokeRemoveHook</span>(ch)</span><br><span class="line">         <span class="title function_">invokeDestroyHook</span>(ch)</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123; <span class="comment">// Text node</span></span><br><span class="line">         <span class="title function_">removeNode</span>(ch.<span class="property">elm</span>)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>就是删除<code>vnodes</code>数组中从<code>startIdx</code>指定位置到<code>endIdx</code>指定位置的内容，<code>removeNode</code>用于删除视图中的单个节点，而<code>removeVnodes</code>用于删除一组指定的节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nodeOps = &#123;</span><br><span class="line">    <span class="title function_">removeChild</span>(<span class="params">node, child</span>) &#123;</span><br><span class="line">        node.<span class="title function_">removeChild</span>(child)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeNode</span> (el) &#123;</span><br><span class="line">    <span class="keyword">const</span> parent = nodeOps.<span class="title function_">parentNode</span>(el)</span><br><span class="line">    <span class="comment">// element may have already been removed due to v-html / v-text</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(parent)) &#123;</span><br><span class="line">      nodeOps.<span class="title function_">removeChild</span>(parent, el)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>nodeOps</code>的封装是为了更好地进行跨平台渲染，这里的逻辑就是将当前的元素从它的父节点中删除，<code>noideOps</code>是对节点操作的封装</p><h3 id="更新节点"><a href="#更新节点" class="headerlink" title="更新节点"></a>更新节点</h3><p>下图是一个替换文字的简单例子，视图中的文本节点包含的文字是“我是文字”，而当状态发生变化时，将文本改成了“我是文字2“，这时根据改变后的状态生成了新的vnode，然后将vnode与oldVnode进行对比，发现他们是同一个节点，深层次对比后，发现文字发生了变化，最后将真实DOM中的文本改成了<code>vnode</code>中的文字”我是文字2“<br><img src="https://s1.ax1x.com/2020/06/02/ttsKiV.jpg"></p><p>patch的工作流程大致如下图所示：<br><img src="https://s1.ax1x.com/2020/06/02/ttcbTA.jpg"></p><p>静态节点指的是那些一定那渲染到界面上，无论状态如何改变，都不会发生变化的节点</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>静态节点p&gt;</span><br></pre></td></tr></table></figure><p>这就是一个静态节点，即无论状态怎样变化，这个节点都不会受到影响而进行重新渲染，它永远都不需要重新渲染</p><p>当新旧两个虚拟节点不是静态节点并且拥有不同属性时可以根据vnode是否拥有text属性来进行不同的更新</p><h4 id="有text属性"><a href="#有text属性" class="headerlink" title="有text属性"></a>有text属性</h4><p>如果新的<code>vnode</code>拥有<code>text</code>属性那么不论之前的就节点的子节点是什么，都可以直接调用<code>setTextContent</code>方法（浏览器下<code>node.setTextContext</code>）来将视图中DOM节点的内容改为虚拟节点</p><p>当然如果之前的<code>oldVnode</code>中也拥有<code>text</code>属性那么就不需要使用<code>setTextContent</code>来设置相同的文本，只需要直接把真实DOM节点的内容改成新<code>vnode</code>的文本即可</p><h4 id="有children属性"><a href="#有children属性" class="headerlink" title="有children属性"></a>有children属性</h4><p>当<code>vnode</code>有<code>children</code>属性时，如果旧节点<code>有children</code>属性，那么旧需要对新旧节点的<code>children</code>进行详细的对比你并更新</p><p>如果旧虚拟节点没有<code>children</code>属性，那么说明旧的虚拟节点是一个空标签，要么就是一个文本节点，如果是文本节点那么就需要将其清空，然后根据新的<code>vnode</code>的<code>children</code>挨个创建真实的DOM元素节点并插入到视图的DOM中</p><h4 id="无children属性"><a href="#无children属性" class="headerlink" title="无children属性"></a>无children属性</h4><p>当<code>vnode</code>既没有<code>text</code>属性也没有<code>children</code>属性时，说明这个节点是一个空节点，那么这时<code>oldVnode</code>中如果存在子节点就将子节点删除，如果存在文本就将文本删除，直到剩余空标签为止</p><h3 id="更新子节点"><a href="#更新子节点" class="headerlink" title="更新子节点"></a>更新子节点</h3><p>更新子节点大致分为4种操作：更新节点、新增节点、删除节点、移动节点</p><p>对比两个子节点列表（children）首先就是循环，循环newChildren（新子节点列表），每循环到一个新的子节点，就去oldChildren（旧子节点列表）中寻找与之相对应的节点，如果找不到就说明这个子节点是因为状态改变而新增的节点，因此需要创建节点并插入视图，如果找到了相应的节点，那么就执行更新操作</p><h4 id="更新策略"><a href="#更新策略" class="headerlink" title="更新策略"></a>更新策略</h4><p>更新策略主要包括：新增节点、更新节点、移动节点、删除节点</p><h5 id="更新子节点-1"><a href="#更新子节点-1" class="headerlink" title="更新子节点"></a>更新子节点</h5><p>如果我们在newChildren中发现了一个节点同时存在于<code>oldChildren</code>中时我们就需要对这个节点进行更新操作</p><p>如果两个节点同处于两个子节点列表的相同位置，那么这时我们只需要对两个节点进行正常的节点更新操作</p><p>但是如果两个节点处理两个列表的不同位置，那么此时就要进行我们的下一步错做移动节点</p><h5 id="移动子节点"><a href="#移动子节点" class="headerlink" title="移动子节点"></a>移动子节点</h5><p>如上文所述，当与<code>newChildren</code>中的新节点对应节点处于<code>oldChildren</code>的不同位置时，我们就需要进行移动子节点</p><p>移动的基本策略就是将真实DOM中的对应节点移动到newChildren中该节点对应的位置</p><p>通过<code>Node.insertBefore()</code>方法，我们可以成功地将一个已有节点移动到一个指定的位置</p><p>而这个指定位置其实就是<code>newChildren</code>中所有未处理节点的第一个位置</p><h5 id="新增子节点"><a href="#新增子节点" class="headerlink" title="新增子节点"></a>新增子节点</h5><p>当我们在旧子节点列表中没有找到当前子节点列表中的节点时，我们需要创建一个新的节点并且插入到oldChildren中所有未处理节点的前面。节点成功插入DOM后这一次循环也就结束了</p><p>可定有人不理解为什么插入到所有未处理节点的前面而不是插入到已处理节点的后面，可以举例说明一下：</p><p>假如说有以下DOM、newChildren、oldChildren：</p><blockquote><p>DOM &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; [【已处理】，【已处理】，【未处理】，【未处理】]</p></blockquote><blockquote><p>newChildren &#x3D;&gt; [【已处理】，【已处理】，<font color="red">【新节点】</font>，【未处理】]</p></blockquote><blockquote><p>oldChildren &#x3D;&gt; [【已处理】，【已处理】，【未处理】，【未处理】]</p></blockquote><p>此时newChildren中的【新节点】在oldChildren中找不到对应的节点，因此会创建新的节点，并且插入到DOM节点的第三个位置，此时：</p><blockquote><p>DOM &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; [【已处理】，【已处理】，<font color="red">【新节点】</font>，【未处理】，【未处理】]</p></blockquote><p>这样看感觉怎么说都是正确的，因为确实新节点添加到了已处理节点的后面，也可以说时添加到了未处理节点的前面</p><p>但是请看下一个例子：</p><blockquote><p>DOM &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; [【已处理】，【已处理】，<font color="green">【已处理】</font>，【未处理】，【未处理】]</p></blockquote><blockquote><p>newChildren &#x3D;&gt; [【已处理】，【已处理】，<font color="green">【已处理】</font>，<font color="red">【新节点】</font>]</p></blockquote><blockquote><p>oldChildren &#x3D;&gt; [【已处理】，【已处理】，【未处理】，【未处理】]</p></blockquote><p>此时按照添加到已处理节点后面的逻辑思想，下一步操作应该时这样的：</p><blockquote><p>DOM &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; [【已处理】，【已处理】，<font color="green">【已处理】</font>，<font color="red">【新节点】</font>，【未处理】，【未处理】]</p></blockquote><p>但是事与愿违，其实真实按照这种逻辑的操作是这样的：</p><blockquote><p>DOM &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; [【已处理】，【已处理】，<font color="red">【新节点】</font>，<font color="green">【已处理】</font>，【未处理】，【未处理】]</p></blockquote><p>Q&amp;A:</p><p><strong>Q:</strong> 我们会发现在我们的逻辑中本应该被添加到第四位的<font color="red">【新节点】</font>被添加到了第三个位置，为什么呢?</p><p><strong>A：</strong> 原因是我们之前说过更新节点过程中对应<code>newChildren</code>循环搜索是否有同一节点的是<code>oldChildreno</code>但是在旧子节点列表中只有两个已处理节点，因此如果添加到已处理节点后面的话，就是应该添加到第三位，所以在DOM中也会添加到【已处理】的前面</p><p>基于上述情况，我们可以发现真正的创建操作是将新的节点添加到所有未处理节点的前面</p><p>这样我们也发现我们仅仅添加了节点，但是并没有对节点进行删除操作，因此我们下面就来说说子节点的删除操作</p><h5 id="删除子节点"><a href="#删除子节点" class="headerlink" title="删除子节点"></a>删除子节点</h5><p>删除子节点，本质上就是删除那些oldChildren中存在但是newChildren中不存在的节点</p><p>举个例子：</p><blockquote><p> DOM &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; [【已处理】，【已处理】，<font color="green">【已处理】</font>，【未处理】，【未处理】]</p></blockquote><blockquote><p>newChildren &#x3D;&gt; [【已处理】，【已处理】，<font color="green">【已处理】</font>，<font color="red">【新节点】</font>]</p></blockquote><blockquote><p>oldChildren &#x3D;&gt; [【已处理】，【已处理】，【未处理】，【未处理】]</p></blockquote><p>oldChildren中两个【未处理】节点其实都是应该删除的节点，也就是废弃的节点，</p><p>也就是说当newChildren循环一遍以后，如果oldChildren中还有没有处理的节点，那么这些节点就时被废弃且应该删除掉的节点</p><h5 id="更新优化策略"><a href="#更新优化策略" class="headerlink" title="更新优化策略"></a>更新优化策略</h5><p>上述四种操作都是需要的，但不一定都是必须的，通常情况下，并不是所有的子节点的位置都会发生移动，一个节点列表中总会有那么几个节点位置是不变的，那么我们也不必总是循环查找。</p><p>那我们是不是可以更快、更加精准的直到要对比的<code>oldChildren</code>中对应节点的位置呢？或者说我们能不能预测以下这个节点可能处于什么位置，这就是策略更新。</p><p>假设有这样的场景：</p><blockquote><p>我们仅仅更新了列表中某个数据的内容，那么这时我们<code>newChildren</code>中节点对应的位置是不是应该与<code>oldChildren</code>中对应节点所在的位置相同呢？</p></blockquote><p>是的，我们可以尝试这样的操作：当我们循环到newChildren中的一个节点是，我们先判断oldChildren中对应位置的节点是否与这个节点向对应，如果对应那么就可以直接进行节点更新，如果不对应，我们再进行循环查找，</p><p>这样很大程度上避免了每次都循环oldChildren来查找节点，这样大大提升了执行的速度</p><p>而查找方式可以分为4种：</p><ul><li>新前与旧前</li><li>新前与旧后</li><li>新后与旧后</li><li>新后与旧前</li></ul><blockquote><p>新前：newChildren中所有未处理节点的第一个节点，<strong>newStartVnode</strong></p><p>新后：newChildren中所有未处理节点的最后一个节点，<strong>newEndVnode</strong></p><p>旧前：oldChioldren中所有未处理节点的第一个节点，<strong>oldStartVnode</strong></p><p>旧后：oldChildren中所有未处理节点的最后一个节点，<strong>oldEndVnode</strong></p></blockquote><hr><h6 id="新前与旧前"><a href="#新前与旧前" class="headerlink" title="新前与旧前"></a>新前与旧前</h6><p>意思就是我们尝试对比“新前”与“旧前”是否是同一个节点，如果是那就不需要执行移动操作，只需要对这个节点进行更新即可</p><h6 id="新后与旧后"><a href="#新后与旧后" class="headerlink" title="新后与旧后"></a>新后与旧后</h6><p>与上一个相同，只需要使用“新后”与“旧后”对比，如果是那就不需要执行移动操作，只需要对这个节点进行更新即可</p><h6 id="新后与旧前"><a href="#新后与旧前" class="headerlink" title="新后与旧前"></a>新后与旧前</h6><p>当我开始理解这个概念的时候直接弄错了“新后”与旧前的概念，<font color="red">建议看到这里重新看一下上面关于这四个概念的解释</font></p><p>当我们对比“新后”与“旧前”，发现他们是对应节点后，我们应该在更新DOM的同时将节点移动到<code>oldChildren</code>所有未处理节点的最后面</p><p>Q：为什么要移动到oldChildren所有未处理节点的最后面</p><p>A：我们都知道更新节点时以新虚拟节点未基准的，而我们知道“新后”是<code>newChildren</code>所有未处理节点的最后一个，因此在对应移动时我们需要将真实DOM中的这个节点移动到最后</p><p>但是“移动到真实节点的最后面”和“移动到<code>oldChildren</code>所有未处理节点的最后面“有区别吗？</p><p>答案是：有的！</p><p>假设newChildren、oldChildren和DOM中的首尾节点都已经处理完毕了，那么此时我们对比“新后”与“旧前”，发现他们一致，这时我们如果将DOM中的节点移动到DOM节点的最后，就会发现位置不匹配，DOM中这个节点在之前尾部【已处理】节点的后面，而newChildren中这个节点在尾部【已处理】节点的前面，位置不匹配，因此才需要移动到oldChildren中所有未处理节点的最后面</p><h6 id="新前与旧后"><a href="#新前与旧后" class="headerlink" title="新前与旧后"></a>新前与旧后</h6><p>”新前“与”旧后“的处理原则与上面的”新后”与“旧前“的处理原则时一致的，这里就不细说了，举一反三！ ^-^</p><hr><p>当以上四种方式都没有找到相同节点时，我们再使用循环的方式去搜索节点，看能否找到，这样就减少了很多的循环操作，有效提高了性能</p><h5 id="怎样判断未处理节点"><a href="#怎样判断未处理节点" class="headerlink" title="怎样判断未处理节点"></a>怎样判断未处理节点</h5><p>如果直接让我们来想这个功能的话，其实正常情况下我们直接使用一次循环，从头到尾肯定能保证只有未处理的节点能够进入循环，这样肯定没有错，但是我们有<strong>优化策略</strong>在先，当我们使用优化策略后，已经处理的节点可能并不在前面甚至可能在未处理节点后面，这时该怎么判断呢？</p><p>我们发现上面几种策略都是在列表前后进行操作的，因此我们只要从两边向中间进行循环就可以的，这也就是Vue中采取的策略。</p><p><strong>循环策略：</strong></p><blockquote><p>首先定义4个变量：<code>oldStratIdx</code>、<code>oldEndIdx</code>、<code>newStartIdx</code>和<code>newEndIdx</code></p><p>分别记录了<code>oldChildren</code>和<code>newChildren</code>循环开始的位置和循环结束的位置</p><p>当开始位置的节点被处理后，就将开始下标后移一位，结束位置的节点被处理后，将结束位置下标前移一位，这样就能保证从两边向中间循环</p><p>结束循环的判断条件是这样的：当开始位置大于等于结束位置时就说明所有节点已经遍历过了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="comment">//内部循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以发现当oldChildren或者newChildren中有一个循环完毕就会退出循环，也就是时可能存在无法覆盖其全部节点对的情况，为什么呢？没有覆盖的节点怎么处理呢？</p><p>细细思考一下就会发现，循环是能够找出差异的，这不也正是我们循环的目的吗？</p><p>当oldChildren先循环结束时，newChildren中多出来的节点就都是新增的节点，也就是需要新创建的节点</p><p>当newChildren先循环结束时，oldChildren中剩余的节点就都是需要删除的，这时就不需要进行循环比对，直接删除就可以了.</p></blockquote><h6 id="key"><a href="#key" class="headerlink" title="key"></a>key</h6><p>当然我们都知道使用Vue渲染列表时，推荐使用属性<code>key</code>，这时因为使用<code>key</code>与<code>index</code>索引建立关系后，相当于拥有了唯一ID，这时查找节点不需要进入循环，只需要直接更新对应位置的节点就可以了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是Vue的虚拟DOM的知识，在虚拟DOM中，最重要的技术就是：patch，虚拟DOM的应用有效提高了性能，减少了可见的 DOM操作，对开发有很大的帮助</p><h2 id="文后自言"><a href="#文后自言" class="headerlink" title="文后自言"></a>文后自言</h2><p>这是自更新博客后第一次写这么长的文章（貌似除了论文还没写过这么多字），受益匪浅，推荐几个受益良多的书籍与博客吧</p><ul><li>刘博文的《深入浅出Vue.js》</li><li><a href="https://juejin.im/user/5c45ddf06fb9a04a006f5491/posts">神三元</a> 的浏览器，原生JS，HTTP系列文章</li><li><strong>axuebin</strong>的 <a href="https://juejin.im/post/5e8b163ff265da47ee3f54a6#heading-12">前端知识脑图</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue2 </tag>
            
            <tag> Vue原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFC小结</title>
      <link href="/2020/06/03/BFC%E5%B0%8F%E7%BB%93/"/>
      <url>/2020/06/03/BFC%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="BFC小结"><a href="#BFC小结" class="headerlink" title="BFC小结"></a>BFC小结</h1><p>之前并没有系统地了解过什么是BFC以及它有什么作用，学习之后才发现以前遇到的很多问题都是可以使用BFC解决的</p><h2 id="什么是BFC"><a href="#什么是BFC" class="headerlink" title="什么是BFC"></a>什么是BFC</h2><blockquote><p>W3C对BFC的定义如下： 浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为”visiable”的块级盒子，都会为他们的内容创建新的BFC（Block Fromatting Context， 即块级格式上下文）</p></blockquote><p>我们常说的文档流其实分为定位流、浮动流和普通流三种，而普通流其实就是指<strong>BFC</strong>中的<strong>FC</strong></p><p><strong>FC</strong>是formating context的缩写，也就是格式化上下文，决定了其子元素如何布局以及与其他元素之间的关系</p><p>常见的<strong>FC</strong>有BFC（块级格式化上下文）、IFC（行级格式化上下文）、GFC（网格布局格式化上下文）和FFC（自适应格式化上下文）</p><p><strong>BFC</strong>是通过一些特定的属性设置而使元素脱离普通流的束缚形成完全独立的区域，且内部元素与外部元素不会产生相互影响</p><h2 id="BFC的触发条件"><a href="#BFC的触发条件" class="headerlink" title="BFC的触发条件"></a>BFC的触发条件</h2><p>BFC的触发条件有下列几种：</p><ul><li>根元素，即HTML元素</li><li>浮动元素： <code>float</code> 不为 <code>none</code></li><li>绝对定位元素：<code>position</code> 设置为 <code>absolute</code> 或 <code>fixed</code></li><li>行内块级元素：<code>display</code> 设置为 <code>inline-block</code></li><li>表格单元格：<code>display</code> 设置为 <code>table-cell</code></li><li>表格标题： <code>display</code> 设置为 <code>table-caption</code></li><li><code>overflow</code> 值不为 <code>visible</code> 的块元素 - 弹性盒元素(flex)</li><li>网格元素：<code>display</code>为<code>grid</code> 或 <code>inline-grid</code> 元素的直接子元素</li></ul><h2 id="BFC的布局规则"><a href="#BFC的布局规则" class="headerlink" title="BFC的布局规则"></a>BFC的布局规则</h2><ul><li>内部的Box会在垂直方向一个接一个地进行放置</li><li>属于同一个BFC的两个Box的margin会发生重叠</li><li>BFC区域不会与float的box重叠</li><li>BFC是一个独立的容器，内部元素不会与外部元素产生相互影响</li><li>计算BFC高度时浮动元素也会参与计算</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="解决父元素塌陷问题"><a href="#解决父元素塌陷问题" class="headerlink" title="解决父元素塌陷问题"></a>解决父元素塌陷问题</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>BFCtest<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    * &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.father</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border</span>: <span class="number">5px</span> solid lightskyblue;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.child</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/05/31/t1DgfA.png"></p><p>将内部child设置为浮动</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/05/31/t1r9k4.jpg"></p><p>此时发现父元素发生了塌陷，这是将父元素设置为BFC这样就解决了父元素塌陷的问题</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span> solid lightskyblue;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="避免外边距重叠"><a href="#避免外边距重叠" class="headerlink" title="避免外边距重叠"></a>避免外边距重叠</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>同一BFC外边距重叠<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    * &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: lightskyblue;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.inner</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: coral;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span>1div&gt;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span>2div&gt;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span>3div&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/05/31/t1yrwT.jpg"></p><p>我们会发现每两个inner元素之间的间距都是10px，这是因为外层container元素为BFC，所以内部子元素发生了margin重叠，我们BFC内部与外部是不会相互影响的，那么这时我们将内部元素封装进BFC中那么就不会出现margin重叠的情况了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bfc&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bfc</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/05/31/t1cYxs.jpg"></p><p>这时就会发现<code>2</code>对应的元素上下边距已经不再重合了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我学习BFC的内容，示例来源于 <a href="http://47.98.159.95/my_blog/css/008.html">神三元</a> 大佬的博客，BFC的概念相对抽象，但是通过这些示例能够清除地了解BFc的重要性，同时我也参考了另外两篇文章 <a href="https://juejin.im/post/5909db2fda2f60005d2093db">[布局概念] 关于CSS-BFC深入理解</a> 、<a href="https://juejin.im/post/59b73d5bf265da064618731d">学习 BFC (Block Formatting Context)</a></p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>致力于做一个有灵魂的搬运工！！！！</p><p>至此完成了我给自己规定的5日学习目标，明天开始更新算法、Vue源码、Js高级进阶等相关的内容！</p>]]></content>
      
      
      <categories>
          
          <category> Css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我所理解的JavaScript的深浅拷贝</title>
      <link href="/2020/06/02/%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84JavaScript%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2020/06/02/%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84JavaScript%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="我所理解的JavaScript的深浅拷贝"><a href="#我所理解的JavaScript的深浅拷贝" class="headerlink" title="我所理解的JavaScript的深浅拷贝"></a>我所理解的JavaScript的深浅拷贝</h1><p>这并不是我第一次接触这个话题，但是这是我第一次深入地对javaScript的深浅拷贝机制进行学习</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>我们都知道javaScript拥有很多数据类型我们将他们分为两种：</p><ul><li>基本数据类型</li><li>引用数据类型</li></ul><p>基本数据类型包括：<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>undefined</code>、<code>null</code>、<code>symbol</code>(es6)</p><p>引用数据类型包括：<code>Object</code>(对象)、<code>Array</code>(数组)、<code>Function</code>(函数)</p><p>对于基本数据类型来说，变量直接按值存放在栈内存的简单数据段中，可以直接进行访问，因此并不存在深浅拷贝的区别，</p><p>引用类型存放在堆内存中，变量保存的是一个指针，当我们需要访问引用类型的值的时候，首先从栈中获得该对象的地址指针，然后从堆中取得需要的数据</p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>什么是浅拷贝？</p><p>答： 浅拷贝就是只复制了引用，而没有复制真正的值，浅拷贝会使两者指向同一块内存空间</p><p>使用<code>=</code>进行浅拷贝是我们做常用的操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> originObj = &#123;<span class="attr">name</span>: <span class="string">&#x27;a&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span>, <span class="attr">favorite</span>: &#123;<span class="attr">obj</span>: <span class="string">&#x27;sing&#x27;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cloneArray = originArray; </span><br><span class="line"><span class="keyword">const</span> cloneObj = originObj;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cloneArray); <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cloneObj); <span class="comment">// &#123;name: &#x27;a&#x27;, age: 30, favorite: &#123;obj: &#x27;sing&#x27;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">cloneArray.<span class="title function_">push</span>(<span class="number">6</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(originArray); <span class="comment">// [1,2,3,4,6]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cloneArray); <span class="comment">// [1,2,3,4,6]</span></span><br><span class="line"></span><br><span class="line">cloneObj.<span class="property">name</span> = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(originObj); <span class="comment">// &#123;name: &#x27;b&#x27;, age: 30, favorite: &#123;obj: &#x27;sing&#x27;&#125;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cloneObj); <span class="comment">// &#123;name: &#x27;b&#x27;, age: 30, favorite: &#123;obj: &#x27;sing&#x27;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(originObj === cloneObj) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>以上代码使用了<code>=</code>进行了浅拷贝操作，<code>clone</code>和<code>origin</code>指向的是同一块内存空间，因此一个引用的值发生改变时，代表着两个对象的值全都被修改了</p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>不同于浅拷贝，深拷贝是对目标的完全拷贝，深拷贝并不只是复制了引用，而是将值也一并复制，使用了新的内存空间，成为新的数据，与旧数据互不影响</p><p>常用的深拷贝方法：</p><ul><li>利用JSON对象的<code>parse()</code>和<code>stringify()</code></li><li>利用递归实现对每一层次的重新创建和赋值</li></ul><h3 id="JSON-stringify-和JSON-parse-方法"><a href="#JSON-stringify-和JSON-parse-方法" class="headerlink" title="JSON.stringify()和JSON.parse()方法"></a>JSON.stringify()和JSON.parse()方法</h3><p>他们都是做什么的呢？</p><blockquote><p>The <code>JSON.parse()</code> method parses a JSON string, constructing the JavaScript value or object described by the string. An optional reviver function can be provided to perform a transformation on the resulting object before it is returned.</p></blockquote><p><code>JSON.parse()</code>是将一个JSON字符串转换为<code>Javascript</code>值或对象</p><blockquote><p>The <code>JSON.stringify()</code> method converts a JavaScript object or value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.</p></blockquote><p><code>JSON.stringify()</code>是将一个<code>JavaScript</code>值转换为<code>JSON</code>字符串</p><p>多说无益，直接代码分析：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> originArr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> cloneArr = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(originArr));</span><br><span class="line"></span><br><span class="line">cloneArr.<span class="title function_">push</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(originArr); <span class="comment">//[ 1, 2, 3, 4 ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cloneArr); <span class="comment">//[ 1, 2, 3, 4, 6 ]</span></span><br></pre></td></tr></table></figure><p>可以看出进行深拷贝之后，原数组的值并没有因为新的数组值改变而改变，十分方便</p><p>但是这种方法也是有一定缺点的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originObj = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;axuebin&#x27;</span>,</span><br><span class="line">  <span class="attr">sayHello</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(originObj); <span class="comment">// &#123;name: &quot;axuebin&quot;, sayHello: ƒ&#125;</span></span><br><span class="line"><span class="keyword">const</span> cloneObj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(originObj));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cloneObj); <span class="comment">// &#123;name: &quot;axuebin&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>此时发现<code>sayHello</code>并没有被加入到<code>cloneObj</code>中，多方查阅发现<code>MDN</code>有所规定：</p><blockquote><p>If undefined, a function, or a symbol is encountered during conversion it is either omitted (when it is found in an object) or censored to null (when it is found in an array). JSON.stringify can also just return undefined when passing in “pure” values like JSON.stringify(function(){}) or JSON.stringify(undefined).</p></blockquote><p>使用上述方法时<code>function</code>、<code>undefined</code>、<code>symbol</code>会被自动忽略，因此当我们的原对象中含有函数时我们不能使用这种方法进行深拷贝</p><h3 id="递归方法实现深拷贝"><a href="#递归方法实现深拷贝" class="headerlink" title="递归方法实现深拷贝"></a>递归方法实现深拷贝</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">oldObj</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> newObj = oldObj.<span class="property">constructor</span> === <span class="title class_">Array</span> ? [] : &#123;&#125;;<span class="comment">//判断目标为数组还是对象并</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> oldObj) &#123;</span><br><span class="line">    <span class="keyword">if</span>(oldObj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      <span class="keyword">if</span>(oldObj[key] &amp;&amp; <span class="keyword">typeof</span> oldObj[key] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        newObj[key] = <span class="title function_">deepClone</span>(oldObj[key])</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newObj[key] = oldObj[key]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用以下方法验证一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oldObj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="attr">b</span>: &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">favorite</span>: <span class="string">&#x27;coding&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="title function_">deepClone</span>(oldObj);</span><br><span class="line"></span><br><span class="line">newObj.<span class="property">b</span>.<span class="property">age</span> = <span class="number">19</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(oldObj); <span class="comment">//&#123; name: &#x27;a&#x27;, b: &#123; age: 20, favorite: &#x27;coding&#x27; &#125;, sayHello: [Function: sayHello] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj); <span class="comment">//&#123; name: &#x27;a&#x27;, b: &#123; age: 19, favorite: &#x27;coding&#x27; &#125;, sayHello: [Function: sayHello] &#125;</span></span><br></pre></td></tr></table></figure><p>经过验证这个函数完美实现了深拷贝</p><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p>先来看一下MDN对于这个函数的解释</p><blockquote><p>The <code>Object.assign()</code> method copies all enumerable own properties from one or more source objects to a target object. It returns the target object.</p></blockquote><p><code>Object.assgin()</code>方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">g</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">  <span class="attr">c</span>: [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> y = <span class="title class_">Object</span>.<span class="title function_">assgin</span>(&#123;&#125;, x);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y.<span class="property">b</span>.<span class="property">f</span> === x.<span class="property">b</span>.<span class="property">f</span>) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">g</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">  <span class="attr">c</span>: [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> y = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, x);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y.<span class="property">b</span>.<span class="property">f</span> === x.<span class="property">b</span>.<span class="property">f</span>) <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">//&#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [ 1, 2, 3 ] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y); <span class="comment">//&#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [ 1, 2, 3 ] &#125;</span></span><br><span class="line"></span><br><span class="line">x.<span class="property">a</span> = <span class="number">2</span>;</span><br><span class="line">x.<span class="property">b</span>.<span class="property">f</span>.<span class="property">g</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">//&#123; a: 2, b: &#123; f: &#123; g: 2 &#125; &#125;, c: [ 1, 2, 3 ] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y) <span class="comment">//&#123; a: 1, b: &#123; f: &#123; g: 2 &#125; &#125;, c: [ 1, 2, 3 ] &#125;</span></span><br></pre></td></tr></table></figure><p>由上述代码可知<code>Object.assgin</code>仅仅只是对源对象的第一层进行了深拷贝，而对于内层以及更深层次的对象却只是进行了浅拷贝</p><h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><blockquote><p>The <code>concat()</code> method is used to merge two or more arrays. This method does not change the existing arrays, but instead returns a new array.</p></blockquote><p><code>concat()</code> 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。<br>开起来是对源数组进行了一次深拷贝，具体状况我们可以试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originArr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> cloneArr = originArr.<span class="title function_">concat</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(originArr === cloneArr); <span class="comment">//false</span></span><br><span class="line">originArr.<span class="title function_">push</span>(<span class="number">6</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(originArr); <span class="comment">// [1,2,3,4,6]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cloneArr) <span class="comment">// [1,2,3,4]</span></span><br><span class="line"></span><br><span class="line">originArr.<span class="title function_">push</span>([<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">const</span> cloneArr2 = originArr.<span class="title function_">concat</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(originArr); <span class="comment">//[ 1, 2, 3, 4, 6, [ 1, 5, 4 ] ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cloneArr2) <span class="comment">// [ 1, 2, 3, 4, 6, [ 1, 5, 4 ] ]</span></span><br><span class="line">originArr[<span class="number">5</span>].<span class="title function_">push</span>(<span class="number">6</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(originArr); <span class="comment">//[ 1, 2, 3, 4, 6, [ 1, 5, 4, 6 ] ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cloneArr2) <span class="comment">// [ 1, 2, 3, 4, 6, [ 1, 5, 4, 6 ] ]</span></span><br></pre></td></tr></table></figure><p>由此可见<code>concat</code>也仅仅只是对源数组的第一层进行了深拷贝</p><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><blockquote><p>The <strong><code>slice()</code></strong> method returns a shallow copy of a portion of an array into a new array object selected from <code>begin</code> to <code>end</code> (<code>end</code> not included) where <code>begin</code> and <code>end</code> represent the index of items in that array. The original array will not be modified.</p></blockquote><p>在MDN的定义中已经明确写了<strong>shallow copy</strong>，但是通过阅读 <a href="https://github.com/axuebin">axuebin</a> 的博客文章我发现<code>slice</code>方法的确不是完全的浅拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originArr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]];</span><br><span class="line"><span class="keyword">const</span> cloneArr = originArr.<span class="title function_">slice</span>();</span><br><span class="line"></span><br><span class="line">originArr.<span class="title function_">push</span>(<span class="number">9</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(originArr); <span class="comment">//[ 1, 2, 3, 4, [ 5, 6, 7, 8 ], 9 ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cloneArr); <span class="comment">//[ 1, 2, 3, 4, [ 5, 6, 7, 8 ] ]</span></span><br></pre></td></tr></table></figure><p>通过实验证明，<code>Array.prototype.slice()</code>的确并非全部浅拷贝，而是对源数组的第一层进行了深拷贝！</p><h3 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h3><p>为什么会出现只对第一层进行了深拷贝的情况呢？</p><p>答：因为在数组或对象中，对内层或跟深层的数组或对象都是存储了一个指针引用，而这些函数在底层实现时都是直接将第一层的数据和引用拷贝下来，因此就形成了只有首层是深拷贝的情况。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>对于<code>=</code>赋值运算符来说，仅仅是进行了浅拷贝，只是拷贝了对象或数组的引用</li><li><code>JSON.stringify()</code>实现了深拷贝，但是会自动省略源对象中的<code>undefined</code>、<code>function</code>、<code>symbol</code></li><li>其他js中的函数大多数都只是实现了首层的深拷贝和内层的浅拷贝</li><li>递归方法是实现完全深拷贝最简单有效的方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 工具 </tag>
            
            <tag> Js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防抖与节流</title>
      <link href="/2020/06/01/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
      <url>/2020/06/01/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h1><p>第一次接触防抖与节流的概念是在一次面试中，但是当时并没有觉得防抖与节流很重要，知道后来学习vue做项目的时候才明白，防抖与节流能够有效地节省浏览器资源，因此更加深入地学习了防抖与节流的知识</p><h2 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h2><blockquote><p>当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。</p></blockquote><p>在一个页面中我们会发现点击一次↓键会触发很多次scroll事件，如果我们在scroll事件中添加对是否显示回到顶部按钮条件的判定，那么这时会消耗大量的浏览器资源，做很多无用功，此时我们就需要<strong>防抖函数</strong>的出场了</p><p>我们提出这样一种设想： 当我们触发第一次scroll事件时启动一个延时函数，如果延时时间内再次触发了scroll事件，那么此时我们重新开始计时，直到延时时间内没有再次触发该事件然后再执行事件对应的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, deplay = <span class="number">1000</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(fn, deplay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>setTimeout()</code>，如果我们没有给<code>deplay</code>进行赋值，将会赋予其默认值<code>1000ms</code><br>简单修改之后，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, deplay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(timer) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">        &#125;, deplay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适用场景：</p><ul><li>表单提交场景：可以防止多次点击提交按钮，只执行最后一次的提交操作</li><li>服务端验证场景：如联想搜索，表单验证等，只执行最后一次输入后触发得到事件</li></ul><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><blockquote><p>节流就是指连续触发事件，但是在n秒规定时间内只会执行一次函数</p></blockquote><p>节流的使用虽然带来了很多便利，但是依旧有一些情况是防抖处理不了的，例如：当一个页面在浏览器中被打开，一个用户不断上下拖动进度条，此时我们</p><p>将永远不会执行scroll事件中的处理函数，因此我们需要使用另外一种策略，当用户第一次触发事件后一段时间内再次触发会失效，这也就是<strong>节流</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">throttle</span> = (<span class="params">func, deplay = <span class="number">500</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!flag) <span class="keyword">return</span>;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">      flag =<span class="literal">true</span></span><br><span class="line">    &#125;, deplay)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>代码解析：</strong> 当我们第一次触发事件时，<code>flag=true</code>，此时将<code>flag</code>设定为<code>false</code>即锁定函数，开始计时执行处理函数，计时期间内再次触发事件时，<code>flag = false</code>直接跳过所有步骤使本次触发失效</p><p>通过阅读文章我还找到了另外一种方法，使使用时间戳进行判定的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">throttle</span> = (<span class="params">func, deplay = <span class="number">500</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> preTime = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="keyword">let</span> context = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">if</span>(now - preTime &gt; deplay) &#123;</span><br><span class="line">      func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">      preTime = now</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解析：</strong> 其实这个时间戳的版本也很好理解，每次触发事件获取一次现在的时间，如果与初次触发时间的差大于等待时间，那么执行函数，如果小于或等于即不执行</p><p><strong>区别：</strong> 以上两种方法的区别就是，使用定时器会在延时以后执行函数，而时间戳方式是立即执行</p><p><strong>试用场景：</strong></p><ul><li>拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动</li><li>缩放场景：监控浏览器resize</li><li>动画场景：避免短时间内多次触发动画引起性能问题</li><li>部分后台系统表单中的快捷操作按钮</li></ul>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 浏览器 </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我所理解的Event-loop</title>
      <link href="/2020/05/31/%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84Event-loop/"/>
      <url>/2020/05/31/%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84Event-loop/</url>
      
        <content type="html"><![CDATA[<h1 id="javaScript的执行机制（Event-Loop）"><a href="#javaScript的执行机制（Event-Loop）" class="headerlink" title="javaScript的执行机制（Event-Loop）"></a>javaScript的执行机制（Event-Loop）</h1><p>对于一个前端工程师来说，理解js的执行机制是一件至关重要的事情</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line"><span class="comment">//输出： 10 20</span></span><br></pre></td></tr></table></figure><p>当我们接触到这样的代码，我们心情舒畅，因为一眼就可以看出我们应该先执行那个步骤，再执行哪个步骤，随后我们根据需求添加了定时器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line"><span class="comment">// 20 10</span></span><br></pre></td></tr></table></figure><p>我们遇到了小小的麻烦，执行过程需要考虑定时器的使用，这还算可以接受，但是随着需求增加我们使用<code>定时器</code>，<code>async</code>，<code>promise</code>等等异步操作的次数也会越来越多，我们会觉得执行更加复杂，甚至心态爆炸，因此我们必须理解js的执行机制，才能有效解决这个难以处理的问题</p><h2 id="javaScript的事件循环"><a href="#javaScript的事件循环" class="headerlink" title="javaScript的事件循环"></a>javaScript的事件循环</h2><p>我们总会听到js是一门<strong>单线程</strong>语言，虽然随着语言的发展，技术大牛们也在探索<strong>多线程</strong>的发展，但是至今为止所有的<strong>类似多线程</strong>都是用单线程模拟出来的</p><p>由于Js是单线程，所以正常情况下代码是顺序执行的，但是很多时候有些代码不需要直接执行，因此我们把javascript中单线程任务分为以下两类：</p><ul><li>同步任务</li><li>异步任务</li></ul><h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p>任务队列<strong>task Queue</strong>，即队列，是先进先出的数据结构</p><h3 id="MacroTask（宏任务）"><a href="#MacroTask（宏任务）" class="headerlink" title="MacroTask（宏任务）"></a>MacroTask（宏任务）</h3><ul><li>js的全部代码，<code>setimeout</code>、<code>setInterval</code>、<code>setImmediate</code>、<code>I/O</code>、<code>UI Rendering</code></li></ul><h3 id="MicroTask（微任务）"><a href="#MicroTask（微任务）" class="headerlink" title="MicroTask（微任务）"></a>MicroTask（微任务）</h3><ul><li><code>Process.nextTick()</code>、<code>Promise</code>、<code>Object.observe(废弃)</code>、<code>MutationObserver</code></li></ul><p>从以上导图可以看出：</p><ul><li>同步与异步任务分别在不同场所执行，同步任务进去主线程，异步任务进入<code>Event Table</code>并为异步任务注册回调函数</li><li>任务完成后<code>EventTable</code>会将任务放入<code>EventQueue</code></li><li>主线程内的任务执行完毕后任务队列此时为空，任务队列会读取<code>Event Queue</code>中的任务加入队列，进入主线程执行</li><li>以上过程不断重复，即为事件循环(Event Loop)</li></ul><p>js引擎中存在<code>monitoring process</code>进程，它会不断地对主线程任务栈进行检查，一旦任务栈为空，则会去<code>Event Queue</code>检查是否有等待调用的函数</p><h3 id="Event-Table中的执行过程"><a href="#Event-Table中的执行过程" class="headerlink" title="Event Table中的执行过程"></a>Event Table中的执行过程</h3><p>执行栈在执行玩<strong>同步任务</strong>后，查看<strong>执行栈</strong>是否为空，如果执行栈为空，则查<strong>微任务</strong>(<code>microTask</code>)栈是否为空，如果不为空，则执行完成所有的微任务，如果为空则执行<strong>宏任务</strong>(<code>Tasks</code>)</p><p>每一次<strong>宏任务</strong>执行完毕，都检查<strong>微任务队列</strong>是否为空，不为空则按照出对原则（先入先出）执行所有微任务，然后设置<strong>微任务队列</strong>为<code>null</code>，然后执行<strong>宏任务</strong>，如此循环</p><h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p>ajax技术是最常用到的数据异步数据请求技术，作为异步请求，他的执行顺序完全符合上面的流程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [];</span><br><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;www.sleepygod.xyz&quot;</span>,</span><br><span class="line">    <span class="attr">method</span>: post,</span><br><span class="line">    <span class="attr">data</span>: data,</span><br><span class="line">    <span class="attr">success</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数据传输成功！&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;代码执行结束&quot;</span>)</span><br></pre></td></tr></table></figure><p>上面的代码执行顺序就是：</p><ol><li>ajax为异步任务进入Event Table，注册回调函数success</li><li>顺序执行主线程任务打印<code>代码执行结束</code></li><li><code>Event Table</code>中ajax执行结束，<code>success</code>被放入<code>Event Queue</code></li><li>主线程执行完毕，任务栈为空，主线程从<code>Event Queue</code>读取<code>success</code>函数放入主线程执行</li><li>此时打印<code>数据传输成功</code></li></ol><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><p><code>setTimeout</code>是延时执行函数，同样属于异步操作，总见到有人将<code>setTimeout</code>的延时设置为0，其实根据HTML标准，无论怎么设置，最低标准等待时间都是<font color="red">4ms</font></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;start&quot;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;延时操作&quot;</span>)</span><br><span class="line">&#125;, <span class="number">3000</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;end&quot;</span>)</span><br></pre></td></tr></table></figure><p>上面代码的执行过程是这样的：</p><ol><li>打印<code>start</code></li><li>定时器为异步操作，放入Event Table， 注册回调函数</li><li>主任务栈中执行打印<code>end</code></li><li>Event Table中定时器执行完毕，打印操作放入Event Queue</li><li>主任务栈为空，Event Table中的任务放入主线程执行，打印<code>延时操作</code></li></ol><h2 id="复杂示例-面试题"><a href="#复杂示例-面试题" class="headerlink" title="复杂示例(面试题)"></a>复杂示例(面试题)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>);</span><br></pre></td></tr></table></figure><p>执行上述代码时，我们先将代码进行分类：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Tasks: run script、setTimeout callback //宏任务</span><br><span class="line"></span><br><span class="line">MicroTask: Promise.then() //微任务</span><br><span class="line"></span><br><span class="line">Js stack: script</span><br><span class="line"></span><br><span class="line">log: script start, script end</span><br></pre></td></tr></table></figure><p>执行同步代码： 打印<code>script start</code>,<code>script end</code>划分宏任务与微任务进行详细划分</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Tasks: run script、setTimeout callback //宏任务</span><br><span class="line"></span><br><span class="line">MicroTask: Promise1.then() //微任务</span><br><span class="line"></span><br><span class="line">JsTask: Promise1</span><br><span class="line"></span><br><span class="line">log: script start, script end，Promise1</span><br></pre></td></tr></table></figure><p>宏任务执行完毕后，任务栈为空，查询微任务，发现Promise，执行Promise，打印<code>promise1</code>，将.then()回调函数放入微任务</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Tasks: run script、setTimeout callback //宏任务</span><br><span class="line"></span><br><span class="line">MicroTask: //微任务</span><br><span class="line"></span><br><span class="line">JsTask: Promise1.then()</span><br><span class="line"></span><br><span class="line">log: script start, script end，Promise1, Promise2</span><br></pre></td></tr></table></figure><p>继续执行微任务，打印<code>Promise2</code>,微任务栈随即清空</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Tasks: setTimeout callback //宏任务</span><br><span class="line"></span><br><span class="line">MicroTask: //微任务</span><br><span class="line"></span><br><span class="line">JsTask: setTimeout callback</span><br><span class="line"></span><br><span class="line">log: script start, script end，Promise1, Promise2，setTimeout</span><br></pre></td></tr></table></figure><p>继续执行宏任务，执行setTimeout callback打印setTimeout,随即宏任务与微任务全部清空</p><h3 id="async-x2F-await"><a href="#async-x2F-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h3><p><code>async/await</code>是在ES6中加入到javascript的标准异步处理方式</p><p>javascript在底层已经将async&#x2F;await转换为promise和then回调函数</p><h2 id="终极示例"><a href="#终极示例" class="headerlink" title="终极示例"></a>终极示例</h2><p>这是一个摘自掘金作者作者：<a href="https://juejin.im/post/59e85eebf265da430d571f89">ssssyoki</a> 文章中的例子，我研究过后才真正理解了Event Loop的机制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">    process.<span class="title function_">nextTick</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">        <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;7&#x27;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    process.<span class="title function_">nextTick</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;10&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;11&#x27;</span>);</span><br><span class="line">        <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;12&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上述代码的执行顺序如下：</p><ul><li><p>首先执行同步任务 ：</p>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Tasks: script, setTimeout1 callback, setTimeout2 callback  //宏任务</span><br><span class="line"></span><br><span class="line">MicroTasks: process.nextTick1, Promise.then()//微任务</span><br><span class="line"></span><br><span class="line">JsTask: script</span><br><span class="line">log: 1,7</span><br></pre></td></tr></table></figure></li><li><p>同步任务执行结束查询微任务栈，发现微任务，执行微任务：</p>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Tasks: script, setTimeout1 callback, setTimeout2 callback  //宏任务</span><br><span class="line"></span><br><span class="line">MicroTasks: //微任务</span><br><span class="line"></span><br><span class="line">JsTask: Promise.then()</span><br><span class="line">log: 1,7，6，8</span><br></pre></td></tr></table></figure></li><li><p>微任务执行结束，执行宏任务：</p>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Tasks: setTimeout1 callback, setTimeout2 callback  //宏任务</span><br><span class="line"></span><br><span class="line">MicroTasks: process.nextTick, Promise.then()//微任务</span><br><span class="line"></span><br><span class="line">JsTask: setTimeout1 callback</span><br><span class="line">log: 1,7，6，8,2,4</span><br></pre></td></tr></table></figure></li><li><p>宏任务执行结束，查询并执行微任务：</p>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Tasks: setTimeout1 callback, setTimeout2 callback  //宏任务</span><br><span class="line"></span><br><span class="line">MicroTasks: //微任务</span><br><span class="line"></span><br><span class="line">JsTask:  Promise.then()</span><br><span class="line">log: 1,7，6，8,2,4，3，5</span><br></pre></td></tr></table></figure></li><li><p>微任务执行结束，继续执行宏任务，发现setTimeout2:</p>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Tasks: setTimeout2 callback  //宏任务</span><br><span class="line"></span><br><span class="line">MicroTasks:  process.nextTick, Promise.then()//微任务</span><br><span class="line"></span><br><span class="line">JsTask:  setTimeout2 callback </span><br><span class="line">log: 1,7，6，8,2,4，3，5,9,11</span><br></pre></td></tr></table></figure></li><li><p>宏任务执行结束，查询微任务，执行并清空微任务：</p>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Tasks: setTimeout2 callback  //宏任务</span><br><span class="line"></span><br><span class="line">MicroTasks: //微任务</span><br><span class="line"></span><br><span class="line">JsTask: </span><br><span class="line">log: 1,7，6，8,2,4，3，5,9,11,10,12</span><br></pre></td></tr></table></figure><p>process.nextTick属于微任务又优先于所有微任务，有process.nextTick存在时应优先执行process.nextTick。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>javaScript时一门单线程的语言，js的执行机制为事件循环（Event Loop），理解了这一概念将会更有利于之后与js相关知识的学习。</p><p>⚠️ <font color=red>javaScript在浏览器和node中的运行机制并不一致，以上的机制只适用于浏览器环境，并不适用于node环境^-^</font></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 面试 </tag>
            
            <tag> Js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的重绘和回流</title>
      <link href="/2020/05/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81/"/>
      <url>/2020/05/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器的重绘与回流"><a href="#浏览器的重绘与回流" class="headerlink" title="浏览器的重绘与回流"></a>浏览器的重绘与回流</h1><p>这是我在之前面试中遇到的一个问题，今天回想起来正好做一个总结</p><h2 id="浏览器在将页面展示给我们之前都做了什么（渲染机制）"><a href="#浏览器在将页面展示给我们之前都做了什么（渲染机制）" class="headerlink" title="浏览器在将页面展示给我们之前都做了什么（渲染机制）"></a>浏览器在将页面展示给我们之前都做了什么（渲染机制）</h2><p>这其实也是我遇到的一道面试题，与重绘和回流息息相关</p><ol><li>用户输入网址</li><li>浏览器通过DNS获取网站的IP地址</li><li>浏览器尝试与服务器建立连接</li><li>服务器发送永久重定向</li><li>浏览器跟踪重定向地址</li><li>服务器处理请求</li><li>服务器发送HTML响应</li><li>浏览器接收响应，开始解析</li><li>解析<code>html</code>文件，处理并创建<code>DOM</code>树</li><li>解析<code>css</code>样式表， 构建<code>CSSOM</code>树</li><li>将<code>DOM</code>与<code>CSSOM</code>进行结合，构建渲染树(Render Tree)</li><li>根据渲染树来布局(layout)，计算每一个节点的位置</li><li>调用GPU进行绘制(Paint)，合成图层</li><li>重绘(repaint)与回流(reflow)</li></ol><p>当<code>html</code>解析遇到<code>script</code>时会暂停构建DOM，执行js脚本，执行完毕后才会继续构建DOM树，因此将js文件放在<code>html</code>文件底部进行加载才会节省加载时间，加快绘制速度</p><p>浏览器使用流式布局 (Flow Based Layout)，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一</p><hr><h2 id="重绘与回流"><a href="#重绘与回流" class="headerlink" title="重绘与回流"></a>重绘与回流</h2><blockquote><p>回流必将引起重绘，而重绘不一定引起回流</p></blockquote><h3 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h3><p>当<code>Render Tree</code>中部分或全部元素的尺寸、结构、布局、隐藏等发生改变而需要重新构建，浏览器因此重新渲染的过程叫做<font color="red">回流</font><br>会导致回流的操作：</p><ul><li>页面的首次渲染</li><li>浏览器窗口哦的大小发生改变</li><li>元素的尺寸或位置发生改变</li><li>元素的内容发生变化</li><li>元素样式发生改变（字体、隐藏等）</li><li>激活CSS伪类(<code>:after</code>,<code>:before</code>,<code>:hover</code>等)</li><li>调用某些方法</li></ul><p>常用且会导致回流的属性和方法:</p><ul><li><code>clientWidth</code>、<code>clientHeight</code>、<code>clientTop</code>、<code>clientLeft</code></li><li><code>offsetWidth</code>、<code>offsetHeight</code>、<code>offsetTop</code>、<code>offsetLeft</code></li><li><code>scrollWidth</code>、<code>scrollHeight</code>、<code>scrollTop</code>、<code>scrollLeft</code></li><li><code>scrollIntoView()</code>、<code>scrollIntoViewIfNeeded()</code></li><li><code>getComputedStyle()</code></li><li><code>getBoundingClientRect()</code></li><li><code>scrollTo</code></li></ul><h3 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h3><p>当页面元素的样式发生改变且并不影响它在文档中的位置时，浏览器将根据其新属性进行重新绘制，这个过程就是<font color="red">重绘</font></p><h3 id="性能影响"><a href="#性能影响" class="headerlink" title="性能影响"></a>性能影响</h3><p><strong><font color="red">回流比重绘更加影响性能，付出代价更高</font></strong></p><p>有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。</p><p>现代浏览器会对频繁的回流或重绘操作进行优化：</p><p>浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。</p><h3 id="避免的方法"><a href="#避免的方法" class="headerlink" title="避免的方法"></a>避免的方法</h3><h4 id="css"><a href="#css" class="headerlink" title="css"></a>css</h4><ul><li>避免使用<code>table</code>布局</li><li>尽可能在DOM的末端改变<code>class</code></li><li>避免使用多层内联样式</li><li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上</li><li>避免使用<code>css</code>表达式（例如:<code>calc()</code>）</li></ul><h4 id="Js"><a href="#Js" class="headerlink" title="Js"></a>Js</h4><ul><li>避免频繁地操作样式，尽可能地一次性重写style属性</li><li>避免频繁操作DOM，可以创建一个<code>documentFragment</code>,在其上完成所有DOM操作，然后将其加入到文档中</li><li>也可以先为元素设置<code>display: none</code>，操作结束后再把它显示出来。因为在<code>display</code>属性为<code>none</code>的元素上进行的DOM操作不会引发回流和重绘。</li><li>避免频繁读取会引发回流&#x2F;重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li><li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 浏览器 </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript -- this的使用</title>
      <link href="/2020/05/29/JavaScript-this%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/05/29/JavaScript-this%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript-–-this的使用"><a href="#JavaScript-–-this的使用" class="headerlink" title="JavaScript – this的使用"></a>JavaScript – this的使用</h1><hr><p>通过阅读MDN和各类博客复习了一下javascript中this的使用方法，之后也会继续补充相关内容</p><hr><h2 id="什么是this"><a href="#什么是this" class="headerlink" title="什么是this"></a>什么是this</h2><p>在传统的面向对象语言中<code>this</code>关键字指代了当前对象本身，或者是当前对象的一个实例，通过使用<code>this</code>可以对其中方法与属性进行调用</p><p>在<code>javascript</code>中<code>this</code>的指向是临时决定的，而不是在创建时决定的，大多数情况下函数的调用方式决定了<code>this</code>的指向</p><h2 id="全局环境中的this"><a href="#全局环境中的this" class="headerlink" title="全局环境中的this"></a>全局环境中的this</h2><p>无论是否处于严格模式下，在全局环境中this都唯一指向全局对象window（浏览器下）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="variable language_">window</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>) <span class="comment">//3</span></span><br></pre></td></tr></table></figure><hr><h2 id="函数环境中的this"><a href="#函数环境中的this" class="headerlink" title="函数环境中的this"></a>函数环境中的this</h2><h3 id="直接调用"><a href="#直接调用" class="headerlink" title="直接调用"></a>直接调用</h3><ul><li>在非严格模式下直接调用函数，则函数中的this指向全局</li><li>在严格模式下调用函数，则此函数中的this会被赋值为undefined</li><li>非严格模式  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo</span>() === <span class="variable language_">window</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li><li>严格模式  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="string">&quot;use strict&quot;</span><span class="comment">//声明严格模式</span></span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo</span>() === <span class="literal">undefined</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="call-apply"><a href="#call-apply" class="headerlink" title="call(),apply()"></a>call(),apply()</h3><p>在js中可以使用<code>call()</code>或者<code>apply()</code>函数来改变<code>this</code>的指向</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;sleepy-god&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">say</span>(<span class="params">job</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;:&quot;</span> + <span class="variable language_">this</span>.<span class="property">age</span> + <span class="string">&quot;-&quot;</span> + job);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">say.<span class="title function_">call</span>(person, <span class="string">&quot;student&quot;</span>); <span class="comment">//sleepy-god:20-student</span></span><br><span class="line">say-<span class="title function_">apply</span>(person, [<span class="string">&quot;student&quot;</span>]); <span class="comment">//sleepy-god:20-student</span></span><br></pre></td></tr></table></figure><ul><li><code>Function.prototype</code>中的<code>call()</code>和<code>apply()</code>都可以改变this的指向，将<code>this</code>值绑定到调用中的特定对象</li><li><code>call()</code>与<code>apply()</code>作用相同，唯一的不同点就是<code>apply()</code>接收的参数必须时数组形式的</li></ul><h3 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h3><p><code>bind()</code>的用法与<code>call()</code>和<code>apply()</code>类似</p><p><code>this</code>将永久地被绑定到了<code>bind</code>的第一个参数，无论这个函数是如何被调用的</p><p><code>function.bind(thisArg[, arg1[, arg2[, ...]]])</code></p><p>与<code>call()</code>和<code>apply()</code>不同的是<code>call()</code>和<code>apply()</code>会自动执行函数，而<code>bind()</code>不会，<code>bind()</code>会返回一个函数引用</p><p>下面附上一段摘自MDN的源码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span>)&#123;</span><br><span class="line">    (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> slice = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>;</span><br><span class="line">        <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> thatFunc = <span class="variable language_">this</span>,</span><br><span class="line">                thatArg = <span class="variable language_">arguments</span>[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">var</span> args = slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> thatFunc !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">                      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Function.prototype.bind - &#x27;</span> +</span><br><span class="line">             <span class="string">&#x27;what is trying to be bound is not callable&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> funArgs = args.<span class="title function_">concat</span>(slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>))</span><br><span class="line">                <span class="keyword">return</span> thatFunc.<span class="title function_">apply</span>(thatArg, funcArgs)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过程解析：</p><ul><li>将<code>Array.prototype.slice</code>赋值给变量<code>slice</code></li><li>将<code>bind()</code>传入的第一个参数<code>arguments[0]</code>记录下来，这是要绑定的<code>this</code>，然后将后续参数保存到<code>args</code>变量中</li><li><code>bind()</code>方法返回的是一个函数，<code>funArgs</code>就是将<code>bind()</code>传入的剩余参数和后续返回的函数执行时加入的参数进行拼接</li><li>然后将<code>this</code>指向之前的第一个参数<code>arguments[0]</code></li></ul><h3 id="关于面试中常见的手写call-和apply-方法题目"><a href="#关于面试中常见的手写call-和apply-方法题目" class="headerlink" title="关于面试中常见的手写call()和apply()方法题目"></a>关于面试中常见的手写call()和apply()方法题目</h3><p>浏览了不少博客和文章，发现手写<code>call()</code>,<code>apply()</code>,和<code>bind()</code>是比较常见的面试题目，因此我也总结了一下<code>call()</code>和<code>apply()</code>的方法</p><h4 id="手动实现call-方法"><a href="#手动实现call-方法" class="headerlink" title="手动实现call()方法"></a>手动实现call()方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> context === <span class="string">&#x27;undefined&#x27;</span> || context === <span class="literal">null</span>) &#123;</span><br><span class="line">        context = <span class="variable language_">window</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> result = context.<span class="title function_">fn</span>(...args);</span><br><span class="line">    <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="手动实现apply-方法"><a href="#手动实现apply-方法" class="headerlink" title="手动实现apply()方法"></a>手动实现apply()方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> context === <span class="string">&#x27;undefined&#x27;</span> || context === <span class="literal">null</span>) &#123;</span><br><span class="line">        context = <span class="variable language_">window</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="variable language_">arguments</span>[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">if</span>(args) &#123;</span><br><span class="line">        result = context.<span class="title function_">fn</span>(...args)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = context.<span class="title function_">fn</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考MDN相关词条：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">Function.prototype.bind</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Js基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue学习笔记 — Vue的响应式原理</title>
      <link href="/2020/05/28/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E2%80%94-Vue%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
      <url>/2020/05/28/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E2%80%94-Vue%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="Vue学习笔记-–-Vue的响应式原理"><a href="#Vue学习笔记-–-Vue的响应式原理" class="headerlink" title="Vue学习笔记 – Vue的响应式原理"></a>Vue学习笔记 – Vue的响应式原理</h1><p><img src="https://snow-cdn-1259430989.cos.ap-beijing.myqcloud.com/vue2%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86.png" alt="Vue2响应式原理"></p><p>这是Vue官网中提供的响应式原理示意图，总结起来我们最常见到的响应式原理的答案就是：</p><blockquote><p>使用Object.defineProperty将所有属性使用setter和getter进行劫持，在读取数据和写入数据时进行拦截处理</p></blockquote><p>这是我自己总结的响应式流程：<br><img src="https://snow-cdn-1259430989.cos.ap-beijing.myqcloud.com/blog/vue2%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE.png"><br>然而这只是响应式原理中的一小部分，下面时是我用自己的话总结的响应式原理：</p><blockquote><p>Vue的响应式原理是通过使用订阅者-发布者模式，配合Object.defineProperty将所有data中的属性进行写入与 获取的劫持，将每一个属性对应一个Dep对象，解析并存储某一属性所对应的vm实例，当属性值发生改变时，Watcher会通知该属性所关联的所有vm实例进行数据更新，者就是响应式的基本原理</p></blockquote><h2 id="一、什么是Object-defineProperty"><a href="#一、什么是Object-defineProperty" class="headerlink" title="一、什么是Object.defineProperty"></a>一、什么是Object.defineProperty</h2><p><code>Object.defineProperty(obj, prop, descriptor)</code>是js对象操作的常用api之一，他对应的三个参数分别是： 需要被定义属性的对象， 要定义或修改的属性，数据描述符或存取描述符</p><h3 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h3><p>当且仅当该属性的<code>configurable</code>键值为<code>true</code>时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除</p><h3 id="enumerable"><a href="#enumerable" class="headerlink" title="enumerable"></a>enumerable</h3><p>当且仅当该属性的<code>enumerable</code>键值为<code>true</code>时，该属性才会出现在对象的枚举属性中。</p><h3 id="value"><a href="#value" class="headerlink" title="value"></a>value</h3><p>该属性对应的值，可以是任何有效的<code>JavaScript</code>值（数值、对象、函数等）</p><h3 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h3><p>当且仅当该属性的<code>witable</code>键值为<code>true</code>时，属性的值即<code>value</code>，才能被赋值运算符改变。</p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>属性<code>getter</code>函数，如果没有<code>getter</code>，则为<code>undefined</code>。当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入<code>this</code>对象（由于继承关系，这里的<code>this</code>并不一定是定义该属性的对象）该函数的返回值会被用作属性的值</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>属性的<code>setter</code>函数，如果没有<code>setter</code>函数，则为<code>undefined</code>当属性值被修改时，会调用此函数。该方法接收一个参数（也就是被赋予的新值）会传入赋值时的<code>this</code>对象</p><hr><h2 id="二、什么时订阅者-发布者模式"><a href="#二、什么时订阅者-发布者模式" class="headerlink" title="二、什么时订阅者-发布者模式"></a>二、什么时订阅者-发布者模式</h2><p>下面有个场景可以描述订阅者-发布者模式：</p><p>当我们使用微信关注公众号后，公众号会定期想你推送新消息，在这个场景下我们就是订阅者而公众号就是发布者</p><p>我们先定义一个发布者对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//订阅者</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribs</span> = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addSub</span>(<span class="params">sub</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribs</span>.<span class="title function_">push</span>(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">//对订阅者进行遍历，逐一通知修改</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribs</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.<span class="title function_">update</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们定义数个订阅者</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sub1 = &#123;</span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sub1发生改变&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sub2 = &#123;</span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sub2发生改变&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sub3 = &#123;</span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sub3发生改变&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义之后我们将所有订阅者存入发布者对象中，然后进行发布</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>();</span><br><span class="line">dep.<span class="title function_">add</span>(sub1);</span><br><span class="line">dep.<span class="title function_">add</span>(sub2);</span><br><span class="line">dep.<span class="title function_">add</span>(sub3);</span><br><span class="line"></span><br><span class="line">dep.<span class="title function_">notify</span>();</span><br></pre></td></tr></table></figure><p>这样dep就会通知已经进行订阅的用户进行数据修改并更新视图，也就完成了发布者的基本功能</p><p>这里我们直接定义一个订阅者：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">node, name, vm</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">node</span> = node;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm;</span><br><span class="line">    <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">update</span>();</span><br><span class="line">    <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">nodeValue</span> = <span class="variable language_">this</span>.<span class="property">vm</span>[<span class="variable language_">this</span>.<span class="property">name</span>] <span class="comment">//get</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当数据发生改变时，直接使用new Watcher(node, name, this.vm)对数据进行修改</p><h3 id="三、Vue2的响应式原理"><a href="#三、Vue2的响应式原理" class="headerlink" title="三、Vue2的响应式原理"></a>三、Vue2的响应式原理</h3><p>在Vue中我们应该先定义一个Vue的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$options</span> = options;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$data</span> = options.<span class="property">data</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$el</span> = options.<span class="property">el</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  先将data挂载到响应式系统中</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Observe</span>(<span class="variable language_">this</span>.<span class="property">$data</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建发布者对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//订阅者</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribs</span> = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addSub</span>(<span class="params">sub</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribs</span>.<span class="title function_">push</span>(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">//对订阅者进行遍历，逐一通知修改</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribs</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.<span class="title function_">update</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个Observe对象，对data中的属性进行劫持</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Observe</span> &#123;</span><br><span class="line">   <span class="title function_">constructor</span>(<span class="params">data</span>) &#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">data</span> = data;</span><br><span class="line">     <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>.<span class="property">data</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="title function_">defineReactive</span>(<span class="variable language_">this</span>.<span class="property">data</span>, key, data[key])</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">defineReactive</span>(<span class="params">data, key, val</span>) &#123;</span><br><span class="line">     <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>();</span><br><span class="line">     <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, key, &#123;</span><br><span class="line">       <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">       <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">       <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span>(newValue === val) &#123;</span><br><span class="line">           <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">         val = newValue;</span><br><span class="line">           <span class="comment">//通知修改属性</span></span><br><span class="line">         dep.<span class="title function_">notify</span>()</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="keyword">if</span>(<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">           dep.<span class="title function_">addSub</span>(<span class="title class_">Dep</span>.<span class="property">target</span>)</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> val</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>将data中的所有属性使用<code>_proxy</code>进行代理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$options</span> = options;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$el</span> = options.<span class="property">el</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$data</span> = options.<span class="property">data</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将数据挂载到响应式系统</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Observe</span>(<span class="variable language_">this</span>.<span class="property">$data</span>)</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//将data代理到this中</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>.<span class="property">$data</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">_proxy</span>(key)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">_proxy</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>, key, &#123;</span><br><span class="line">      <span class="attr">configurable</span>: <span class="literal">true</span>, </span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">true</span>, </span><br><span class="line">      <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$data</span>[key] = newValue</span><br><span class="line">      &#125;, </span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$data</span>[key]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置订阅者对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">node, name, vm</span>) &#123; <span class="comment">//节点， 属性名， Vue实例</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">node</span> = node;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm;</span><br><span class="line">    <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">update</span>();</span><br><span class="line">    <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//修改视图数据</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">nodeValue</span> = <span class="variable language_">this</span>.<span class="property">vm</span>[<span class="variable language_">this</span>.<span class="property">name</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置正则处理规则</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/\&#123;\&#123;(.*)\&#125;\&#125;/</span>; <span class="comment">//&#123;&#123;&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>配置视图解析对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Compiler</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">el, vm</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">el</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(el);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">frag</span> = <span class="variable language_">this</span>.<span class="title function_">_createFragment</span>();</span><br><span class="line">    <span class="comment">//视图解析创建虚拟节点时会将原节点删除，因此需要重新加入节点</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">el</span>.<span class="title function_">appendChild</span>(<span class="variable language_">this</span>.<span class="property">frag</span>)</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">//创建虚拟节点并对原节点进行解析处理</span></span><br><span class="line">  <span class="title function_">_createFragment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//创建虚拟dom根节点</span></span><br><span class="line">    <span class="keyword">const</span> frag = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> child;</span><br><span class="line">    <span class="comment">//循环搜索节点，解析视图</span></span><br><span class="line">    <span class="keyword">while</span>(child = <span class="variable language_">this</span>.<span class="property">el</span>.<span class="property">firstChild</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">_compile</span>(child);</span><br><span class="line">      frag.<span class="title function_">appendChild</span>(child)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> frag</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//对节点进行解析，并且添加监听和视图修改操作</span></span><br><span class="line">  <span class="title function_">_compile</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(node);</span><br><span class="line">    <span class="keyword">if</span>(node.<span class="property">nodeType</span> === <span class="number">1</span>)&#123; <span class="comment">//标签节点</span></span><br><span class="line">      <span class="keyword">const</span> attrs = node.<span class="property">attributes</span>;</span><br><span class="line">      <span class="keyword">if</span>(attrs.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;v-model&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> name = attrs[<span class="string">&#x27;v-model&#x27;</span>].<span class="property">nodeValue</span>;</span><br><span class="line">        node.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">vm</span>[name] = e.<span class="property">target</span>.<span class="property">value</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(node.<span class="property">nodeType</span> === <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;node: &quot;</span> + node.<span class="property">nodeValue</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(node.<span class="property">nodeValue</span>));</span><br><span class="line">      <span class="keyword">if</span> (reg.<span class="title function_">test</span>(node.<span class="property">nodeValue</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> name = <span class="title class_">RegExp</span>.<span class="property">$1</span>.<span class="title function_">trim</span>()</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name: &#x27;</span> + name);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Watcher</span>(node, name, <span class="variable language_">this</span>.<span class="property">vm</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完善Vue对象的创建过程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$options</span> = options;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$el</span> = options.<span class="property">el</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$data</span> = options.<span class="property">data</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将数据挂载到响应式系统</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Observe</span>(<span class="variable language_">this</span>.<span class="property">$data</span>);</span><br><span class="line">    <span class="comment">// 将data进行代理处理</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>.<span class="property">$data</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">_proxy</span>(key)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将el进行解析并添加订阅者</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Compiler</span>(<span class="variable language_">this</span>.<span class="property">$el</span>, <span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结起来响应式的过程大致如下：</p><ul><li>定义Vue对象，将Vue对象中的data属性值进行响应式挂载， Observe</li><li>在Observe中对每一个属性进行劫持处理，添加setter和getter方法,，在watcher的 update()方法被调用时，会自动执行getter方法，此时将这个Watcher对象（即订阅者）添加到发布者中</li><li>每当数据变化时就会触发该属性对应的Dep对象中的notify()方法，通知所有成员进行数据更新</li><li>订阅者此时触发update()方法，改变了Watcher中对应node的nodeValue，也就是视图显示的数据</li><li>就这样形成了数据的双向绑定，即视图值修改，数据值即修改，反之亦然</li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue2 </tag>
            
            <tag> Vue原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议和HTTP1.01.12.0的区别</title>
      <link href="/2020/05/22/HTTP%E5%8D%8F%E8%AE%AE%E5%92%8CHTTP1-01-12-0%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/05/22/HTTP%E5%8D%8F%E8%AE%AE%E5%92%8CHTTP1-01-12-0%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><h2 id="什么是HTTP协议"><a href="#什么是HTTP协议" class="headerlink" title="什么是HTTP协议"></a>什么是HTTP协议</h2><ul><li>HTTP协议，全称超文本传输协议，属于网络结构OSI参考模型的“最上层”应用层，由请求与响应构成，是无状态的协议。</li><li>HTTP占用默认端口号为80，可承载在TLS和SSL之上，通过加密、认证的方式实现数据传输，即HTTPS协议，默认端口443</li></ul><h2 id="HTTP1-0，HTTP1-1，HTTP2-0的特性与区别"><a href="#HTTP1-0，HTTP1-1，HTTP2-0的特性与区别" class="headerlink" title="HTTP1.0，HTTP1.1，HTTP2.0的特性与区别"></a>HTTP1.0，HTTP1.1，HTTP2.0的特性与区别</h2><ul><li><p>HTTP1.1使用长连接，有效减少三次握手的开销</p></li><li><p>HTTP1.1允许只发送header信息不携带body，此时如果服务器认为客户端拥有权限，就会向客户端发送100，客户端接收100hou再向服务器发送 body信息</p></li><li><p>HTTP1.0没有host域HTTTP1.1才开始支持</p></li><li><p>HTTP1.x的致命缺陷：</p><ul><li>协议规定客户端对同一域的并发连接只能由一个，而一个 页面至少需要加载40个资源</li><li>线头阻塞（Head of line blocking）同一个连接中的请求，需要一个一个的收发，效率太低</li><li>基于文本协议，请求与响应头信息非常大，无法进行压缩</li><li>只能单向请求，即服务端只能返回客户端的指定请求</li></ul></li><li><p>HTTP2.0的特点：使用了多路复用、HOPACK头压缩、流+二进制帧，流优先级等技术</p></li><li><p>HTTP2.0使用了多路复用技术，允许同时通过单一的HTTP&#x2F;2连接发起请求-响应信息，是解决HTTP1.x并发问题和HOLB线头问题的核心技术</p></li><li><p>HTTP2在原有HTTP基础上在应用层（HTTP2）和传输层（TCP&#x2F;UDP）之间增加了二进制分帧层</p></li><li><p>HTTP2允许客户端发送请求后，服务端将所有相关文件一并返回，并加入浏览器缓存，减少请求次数</p></li><li><p>HTTP2带来的好处：</p><ul><li>更小的传输体积，更小甚至省略的头消息</li><li>突破原有的TCP连接并发限制，使用一个TCP可实现多请求并发，减少了服务端的压力</li><li>解决 HOLB 线头问题，慢的请求或者先发送的请求不会阻塞其他请求的返回</li><li>结合CDN提供实时性更高，不会出现先发送的请求阻塞后面的请求</li><li>数据优先级可控</li><li>能在不中断TCP连接的情况下停止数据的发送</li></ul></li></ul><p><img src="/src=%22https:/s1.ax1x.com/2020/07/22/UHlZZD.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美团前端实习面试</title>
      <link href="/2020/03/21/%E7%BE%8E%E5%9B%A2%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95/"/>
      <url>/2020/03/21/%E7%BE%8E%E5%9B%A2%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>面试开始比较戏剧性，我在调整设备时发现聊天室显示对方已经进入房间，我就点了接受面试邀请，面试官小哥哥也还没准备好，商量了一下，面试就这样开始了</p><p>面试官问我我先手写两个代码可以吗，当然同意了！</p><hr><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><blockquote><h3 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value,</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">left</span> = <span class="variable language_">this</span>.<span class="property">right</span> = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BiTree</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归写法</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">Order</span> = (<span class="params">root</span>) =&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">traversal</span> = (<span class="params">root</span>) =&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">left</span>) <span class="title function_">traversal</span>(root.<span class="property">left</span>);</span><br><span class="line">        arr.<span class="title function_">push</span>(root.<span class="property">value</span>);</span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">right</span>) <span class="title function_">traversal</span>(root.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归写法</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">Order</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> arr = [],</span><br><span class="line">        stack = [];</span><br><span class="line">    <span class="keyword">let</span> p = root;</span><br><span class="line">    <span class="keyword">while</span> (stack.<span class="property">length</span> || p) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(p);</span><br><span class="line">            p = p.<span class="property">left</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> node = stack.<span class="title function_">pop</span>();</span><br><span class="line">        arr.<span class="title function_">push</span>(node.<span class="property">value</span>);</span><br><span class="line">        p = node.<span class="property">right</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><hr><h2 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h2><blockquote><h3 id="ES6的特性有哪些"><a href="#ES6的特性有哪些" class="headerlink" title="ES6的特性有哪些"></a>ES6的特性有哪些</h3><p>回答了let，const，块级作用域，promise，class<br>当然不止上述，还有proxy，解构赋值，set，map，箭头函数，Symbol，Module</p><hr><h3 id="解释一下什么是class，class与function体哦那有什么区别"><a href="#解释一下什么是class，class与function体哦那有什么区别" class="headerlink" title="解释一下什么是class，class与function体哦那有什么区别"></a>解释一下什么是class，class与function体哦那有什么区别</h3><p>我的答案是：class实质上是function的一种变形，class是es6对对象的快速定义写法，本质上还是属于function，是一种特殊的function</p><p>面试结束后找到的《ECMAScript 6 入门》（阮一峰）里面的原话：ES6的class可以看作是一个语法糖，class知识让对象原型的写法更加清晰，更向面向对象编程的语法而已</p></blockquote><hr><p>随后面试官看我回答的并不是特别好所以就接着问我用什么其他准备的还阔以的科目，我说计网吧，但是没想到的是我无意间给自己连挖了好几个坑！</p><hr><blockquote><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="说一下OSI参考模型"><a href="#说一下OSI参考模型" class="headerlink" title="说一下OSI参考模型"></a>说一下OSI参考模型</h3><p>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p><hr><h3 id="简单说一下每一层的作用"><a href="#简单说一下每一层的作用" class="headerlink" title="简单说一下每一层的作用"></a>简单说一下每一层的作用</h3><p>这个问题一问我就开始有点慌，但还是稍微答了几个</p><ul><li><p>物理层：定义物理设备的标准，主要对物理连接方式等指定同一标准 协议：IEEE 802.1，IEEE 802.2等</p></li><li><p>数据链路层：对物理层传输的比特流包装，检测保证数据传输的可靠性，可以进行物理寻址</p></li><li><p>网络层：控制子网的运行，提供点到点的服务，提供网络重各个主机之间的数据通信 协议：IP&#x2F;HTTP&#x2F;ICMP&#x2F;IGMP&#x2F;ARP&#x2F;RAPP</p></li><li><p>传输层：定义一些传输数据的协议和端口，可用于建立虚拟链接 协议：TCP&#x2F;UDP</p></li><li><p>会话层：可使应用建立和维持会话，并能使会话获得同步</p></li><li><p>表示层：为异种机通信提供一种公共语言</p></li><li><p>应用层：是网络向用户提供服务的最终窗口，可支持用户联网的应用的要求 协议：FTP&#x2F;SMTP&#x2F;DNS&#x2F;HTTP</p></li></ul><h3 id="TCP和UDP各属于哪一层，有什么区别"><a href="#TCP和UDP各属于哪一层，有什么区别" class="headerlink" title="TCP和UDP各属于哪一层，有什么区别"></a>TCP和UDP各属于哪一层，有什么区别</h3><p>他们都属于传输层协议</p><p>UDP协议全称是用户数据报协议，是一种无连接的协议。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的</p><p>TCP是可靠的面向连接的网络协议，只能进行一对一通信，tcp的连接建立需要三次握手，连接拆除需要四次挥手</p><hr><h3 id="用A-B代表主机模拟Tcp三次握手"><a href="#用A-B代表主机模拟Tcp三次握手" class="headerlink" title="用A,B代表主机模拟Tcp三次握手"></a>用A,B代表主机模拟Tcp三次握手</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SYN(synchronous建立联机)</span></span><br><span class="line"><span class="comment">// ACK(acknowledgement 确认)</span></span><br><span class="line"><span class="comment">// PSH(push传送)</span></span><br><span class="line"><span class="comment">// FIN(finish结束)</span></span><br><span class="line"><span class="comment">// RST(reset重置)</span></span><br><span class="line"><span class="comment">// URG(urgent紧急)</span></span><br><span class="line"><span class="comment">// SEQ(Sequence number顺序号码)</span></span><br><span class="line"><span class="comment">// ack(Acknowledge number确认号码)</span></span><br><span class="line"></span><br><span class="line">A -&gt; <span class="attr">B</span>: <span class="variable constant_">SYN</span> = <span class="number">1</span>, <span class="variable constant_">SEQ</span> = x</span><br><span class="line"></span><br><span class="line">B -&gt; <span class="attr">A</span>: <span class="variable constant_">SYN</span> = <span class="number">1</span>, <span class="variable constant_">ACK</span> = <span class="number">1</span>, ack = x + <span class="number">1</span>, <span class="variable constant_">SEQ</span> = y</span><br><span class="line"></span><br><span class="line">A -&gt; <span class="attr">B</span>: <span class="variable constant_">ACK</span> = <span class="number">1</span>, seq = x + <span class="number">1</span>, ack = y + <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h3 id="HTTP和HTTPS各属于哪一层"><a href="#HTTP和HTTPS各属于哪一层" class="headerlink" title="HTTP和HTTPS各属于哪一层"></a>HTTP和HTTPS各属于哪一层</h3><p>HTTP属于应用层，https用于使用SSL加密属于网络层</p><hr><h3 id="HTTP常见的报头有哪些？"><a href="#HTTP常见的报头有哪些？" class="headerlink" title="HTTP常见的报头有哪些？"></a>HTTP常见的报头有哪些？</h3><p>当时一个都没想起来，下面答案也不全是我后来查到的常用的</p><ul><li><p>Accept: 能正确接收的媒体类型</p></li><li><p>Accept-Encoding: 能正确接受的编码格式列表</p></li><li><p>Cookie: 发给服务器的Cookie信息</p></li><li><p>Host: 服务器域名</p></li><li><p>User-Agent: 客户端信息</p></li><li><p>server: 服务器名字</p></li><li><p>set-cookie: 需要存在客户端的信息，用于识别用户身份</p></li></ul><hr><h3 id="简述一下DNS请求过程"><a href="#简述一下DNS请求过程" class="headerlink" title="简述一下DNS请求过程"></a>简述一下DNS请求过程</h3><p>DNS请求时由浏览器发起的，浏览器先查询自身内存中是否解析过这个域名，如果没有，则向本地服务器发起DNS请求，本地服务器查询到服务器地址即返回服务器地址，如果没有，则本地服务器向根服务器发送请求，根服务器会返回一个所查询域的主域名服务器地址，本地服务器随即向此域名服务器发送请求，域名服务器如果没有查询到，则重复上一步骤，直到查到为止，如果查到了，则查询后返回该域名对应的ip地址，本队服务器将对应ip与域名存储在缓存中，然后将结果返回给用户，用户将地址存在缓存中，DNS解析至此结束</p></blockquote><hr><blockquote><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="什么时进程？什么时线程？"><a href="#什么时进程？什么时线程？" class="headerlink" title="什么时进程？什么时线程？"></a>什么时进程？什么时线程？</h3><p>进程是一个计算机程序运行的过程，进程是计算机资源分配的基本单位，线程是进程中执行运算的一个最小单位，一个进程至少要有一个线程</p><hr><h3 id="进程与进程，线程与线程之间的通信方式有哪些？"><a href="#进程与进程，线程与线程之间的通信方式有哪些？" class="headerlink" title="进程与进程，线程与线程之间的通信方式有哪些？"></a>进程与进程，线程与线程之间的通信方式有哪些？</h3><p>一瞬间想到的是socket通信，随后面试官补充了共享内存（即利用文件进行通信）<br>正确答案：管道（pipe），信号(signal)，消息队列（message queue），共享内存（shared memory），信号量(semaphore)，套接字（socket）</p><hr><h3 id="线程中常见的锁"><a href="#线程中常见的锁" class="headerlink" title="线程中常见的锁"></a>线程中常见的锁</h3><p>公平锁与非公平锁，递归锁，独占锁，共享锁</p><hr><h3 id="简述一下什么是死锁，怎么会形成死锁，死锁的解决方法（完全忘记）"><a href="#简述一下什么是死锁，怎么会形成死锁，死锁的解决方法（完全忘记）" class="headerlink" title="简述一下什么是死锁，怎么会形成死锁，死锁的解决方法（完全忘记）"></a>简述一下什么是死锁，怎么会形成死锁，死锁的解决方法（完全忘记）</h3><p>如果一个进程集合里面的每个进程都在等待这个集合中的其他一个进程（包括自身）才能继续往下执行，若无外力他们将无法推进，这种情况就是死锁，处于死锁状态的进程称为死锁进程。</p><p>产生原因：</p><ol><li><p>因竞争资源发生死锁现象：系统中供多个进程共享的资源的数目不足以满足全部进程的需要时，就会引起对诸资源的竞争而发生死锁现象；</p></li><li><p>进程推进顺序不当发生死锁</p></li></ol><p>形成死锁的四个必要条件：互斥条件，请求和保持条件，不可剥夺条件，环路等待条件</p><p>两个进程同时抢占两个资源，进程1抢到a没抢到b，进程2抢到b没抢到a就会发生死锁</p><p>处理死锁的基本方法</p><ol><li><p>预防死锁：通过设置一些限制条件，去破坏产生死锁的必要条件</p></li><li><p>避免死锁：在资源分配过程中，使用某种方法避免系统进入不安全的状态，从而避免发生死锁</p></li><li><p>检测死锁：允许死锁的发生，但是通过系统的检测之后，采取一些措施，将死锁清除掉</p></li><li><p>解除死锁：该方法与检测死锁配合使用</p></li></ol></blockquote><hr><p>这次面试问题和前两次差不多，这些问题其实大部分都准备过，但是一到面试就忘了，面试官很亲切给我提了很多意见，我虚心采纳，面试官相当nice，就像面试官说的基础知识看似没用，其实是大问题的变形我还需要更多的积累与磨练，这样才能展现更好的自己！！！</p>]]></content>
      
      
      <categories>
          
          <category> 校招 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校招 </tag>
            
            <tag> 美团 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯前端实习生（视频面试）</title>
      <link href="/2020/03/14/%E8%85%BE%E8%AE%AF%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0%E7%94%9F%EF%BC%88%E8%A7%86%E9%A2%91%E9%9D%A2%E8%AF%95%EF%BC%89/"/>
      <url>/2020/03/14/%E8%85%BE%E8%AE%AF%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0%E7%94%9F%EF%BC%88%E8%A7%86%E9%A2%91%E9%9D%A2%E8%AF%95%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>修改简历之后本以为无望，结果9号突然收到了腾讯的面试邀请函，经过询问了解到，腾讯的简历机制是一个部门对你进行面试时会锁定你的简历，然后如果面试没通过就会放开简历，投入简历库，等其他部门来捞</p><p>废话少说，直接进入正题，下面列举我记下的面试时被问到的问题及之后查到的正确答案</p><hr><blockquote><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><h4 id="简述一下OSI参考模型"><a href="#简述一下OSI参考模型" class="headerlink" title="简述一下OSI参考模型"></a>简述一下OSI参考模型</h4><p>物理层，数据链路层，网络层，传输层，会话层，表示层，应用层</p><hr><h4 id="http与https各自时属于哪一层的协议"><a href="#http与https各自时属于哪一层的协议" class="headerlink" title="http与https各自时属于哪一层的协议"></a>http与https各自时属于哪一层的协议</h4><p>http是应用层协议，https是http+ssl协议所以属于网络层协议</p><h4 id="了解状态码吗-403、502各自代表什么"><a href="#了解状态码吗-403、502各自代表什么" class="headerlink" title="了解状态码吗,403、502各自代表什么"></a>了解状态码吗,403、502各自代表什么</h4><p>2xx是请求成功，3xx是重定向，4xx是客户端错误，5xx是服务器错误<br>403是服务器接收请求但是拒绝处理，502是网关错误</p></blockquote><hr><blockquote><h3 id="JS相关"><a href="#JS相关" class="headerlink" title="JS相关"></a>JS相关</h3><h4 id="什么情况下会引发内存泄漏"><a href="#什么情况下会引发内存泄漏" class="headerlink" title="什么情况下会引发内存泄漏"></a>什么情况下会引发内存泄漏</h4><p>当时回答了闭包，下面是后来查到的：</p><ol><li>意外的局部变量</li><li>被遗忘的计时器或回调函数</li><li>闭包</li><li>脱离DOM的引用</li></ol><hr><h4 id="什么是跨域问题，跨域问题源于什么策略，怎么解决跨域问题"><a href="#什么是跨域问题，跨域问题源于什么策略，怎么解决跨域问题" class="headerlink" title="什么是跨域问题，跨域问题源于什么策略，怎么解决跨域问题"></a>什么是跨域问题，跨域问题源于什么策略，怎么解决跨域问题</h4><p>跨域问题是当协议，域名，端口其中任意一个不相同时引起的无法访问</p><p>跨域是由于浏览器的同源策略而产生的</p><p>解决方法：</p><ol><li>JSONP(动态创建script标签和回调函数，模拟get请求)</li><li>CORS response加header(“Access-control-Allow-origin:x”),header(“Access-control-Allow-Method:post&#x2F;Get”)</li><li>nginx转发（使用反向代理，向中间服务器发送请求，中间服务器请求到数据后返回给客户端）</li><li>HttpClient(请求转发)</li></ol></blockquote><hr><blockquote><h3 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h3><p>最让我受刺激的两道题，心态炸裂，也不知道怎么回事，刚看完的都能忘，还是太菜了</p><h4 id="手写一个isArray-判断是不是数组"><a href="#手写一个isArray-判断是不是数组" class="headerlink" title="手写一个isArray()判断是不是数组"></a>手写一个isArray()判断是不是数组</h4> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isArray</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="comment">//1、推荐方式</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(arr) === <span class="string">&quot;[object Array]&quot;</span></span><br><span class="line">  <span class="comment">//2、instanceof判断</span></span><br><span class="line">  <span class="comment">// 千万不能用typeof 返回的是object</span></span><br><span class="line">  <span class="keyword">return</span> arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>;</span><br><span class="line">  <span class="comment">//3、官方方法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="写一个能生成min到max之间随机数的函数"><a href="#写一个能生成min到max之间随机数的函数" class="headerlink" title="写一个能生成min到max之间随机数的函数"></a>写一个能生成min到max之间随机数的函数</h4> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myRandom</span>(<span class="params">min, max</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * max + min);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><hr><p>面试时间很短就半小时，可能是看我着两个代码写的太差劲了，我自己当时都自闭了，问了我一些项目问题，问了学校的实习政策，问了最近学习中遇到的困难，之后就结束了，这次面试时间不长，虽然表现比上一次突然袭击好的多但是还是不尽人意，还不够完美，基础还是不扎实依旧需要磨练，面试结束我也清楚没有二面了，心情的确有点失落，但是还好还有努力空间，还有我自己的学习方向，加油，继续努力！</p><p><img src="/img/yqh.png" alt="腾讯校招邀请函"></p>]]></content>
      
      
      <categories>
          
          <category> 校招 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校招 </tag>
            
            <tag> 秋招 </tag>
            
            <tag> 腾讯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯Web前端开发暑期实习生（提前批）</title>
      <link href="/2020/03/11/%E8%85%BE%E8%AE%AFWeb%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E7%94%9F/"/>
      <url>/2020/03/11/%E8%85%BE%E8%AE%AFWeb%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="人生第一次面试"><a href="#人生第一次面试" class="headerlink" title="人生第一次面试"></a>人生第一次面试</h2><p>3号下午六点突然接到了一个电话，显示微应用的号码，电话里，腾讯的面试官告诉我晚上7点进行电话面试</p><p>心情瞬间开始变得兴奋和紧张</p><p>紧张的是没有什么准备很突然，兴奋是因为这是第一次专业的面试</p><p>虽然总体表现不是很好，但是通过这次面试也给自己找到了很多不足的地方，面试之后总结了题目，发出来共勉一下</p><hr><blockquote><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><p>我说了自己的学习历程，说了些参与过的小项目，获过的奖项，然后就进入了正式的面试环节</p></blockquote><hr><blockquote><h3 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h3><ol><li>JavaScript的数据类型有哪些？<br> 基本数据类型：String 、 Number 、 Boolean 、 null 、 undefined<br> 引用数据类型：Function 、 Object 、 Array</li><li>undefined与null的区别（想起来一大部分有一些是面试后补充的）<br>  undefined表示”缺失值”,null表示没有对象，<br>  undefined与null值相同但是类型不相同<br>  声明变量后不赋值就会默认为undefined，函数无返回值时也会默认undefined，调用函数时没有提供相对应的参数，参数也会默认undefined<br>  null可以用作函数的参数，表示该函数的参数不是对象，也可以作为原型链的终点</li><li>在日常应用中，undefined和null的常用方式<br>  undefined用于清空变量，null用于清空对象</li><li>JSON的格式是什么<br>  <code>&quot;&#123;&quot;key&quot;: &quot;value&quot;, &quot;key&quot;: 1 &#125;&quot;</code></li><li>JS中JSON相关的内置对象<br>  Json.stringify() 将js对象或数组转换为字符串<br>  JSON.parse() 将文本解析为js对象</li></ol></blockquote><hr><p>自我感觉上面答的还可以，主要也是由于那几天在重新温习js和学习es6，脑子里面全是js相关的东西，然而从这后面的就开始了I Don’t Know的旅程</p><blockquote><h3 id="H5"><a href="#H5" class="headerlink" title="H5"></a>H5</h3><ol><li>H5有哪些新特性(这个还是知道的)<br>  audio、video、canvas、article、footer、section、nav、header、表单控件email、date、time、url、search、地理定位、缓存application cach</li><li>简单说一下H5的语义化（说实话一瞬间就懵了，因为不常用所以已经忘了语义化是什么）<br>  将标签优化使页面结构更加清晰，增加可读性，有利于SEO优化；根据文档上下文选择合适的语义化标签等；尽量减少使用无语义化的标签如；添加title和kewords；不使用带有样式的标签，用css设置样式，应用<code>&lt;header&gt;</code>、<code>&lt;body&gt;</code>、<code>&lt;section&gt;</code>、<code>&lt;footer&gt;</code>等易于机器进行识别的标签（后续搜索的答案）</li></ol></blockquote><hr><blockquote><h3 id="浏览器相关"><a href="#浏览器相关" class="headerlink" title="浏览器相关"></a>浏览器相关</h3><ol><li>从用户输入url到页面显示都发生了什么<br>  (1)客户端通过DNS解析获得服务器的ip<br>  (2)三次握手建立tcp链接<br>  (3)浏览器向服务器发送HTTP请求<br>  (4)服务器回应HTTP响应<br>  (5)浏览器接收HTTP响应的数据<br>  (6)浏览器解析html文件，根据标签生成DOM树<br>  (7)浏览器解析css，生成CSSOM树<br>  (8)浏览器将DOM树和CSSOM树合并，构建渲染树<br>  (9)浏览器进行布局、绘制、重绘和回流<br>  (10)浏览器与服务器四次挥手断开链接</li><li>具体描述一下浏览器的重绘与回流<br> 重绘：根据元素的新属性重新绘制，使元素呈现新的外观<br> 回流：当render tree中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变而需要重新构建称为回流<br> 区别：回流一定会引起重绘，而重绘不一定引起回流</li><li>浏览器的缓存类型<br> 协商缓存：每次读取缓存时，先到服务器去验证是否有改变，如果有就获取，没有就从缓存中读取，响应code为304<br> 强制缓存：只要缓存没过有效期，就强制读取缓存，响应code为200，该类缓存必定要持久化到disk</li><li>浏览器的常用缓存机制<br>  http缓存：基于http协议的浏览器文件缓存机制，当重复请求某一个文件时，浏览器可以根据协议的头文件判断是从服务端请求文件还是从本地读取文件<br>  cookies：用于标识用户的一小块数据信息，可在浏览器与服务器之间传递<br>  localStorage：要访问同一个localStorage页面必须同源，没有时间限制的数据存储，主要可用于存储ajax请求返回的数据<br>  sessionStorage：只能被最初存储对象的页面所访问，针对一个session的数据存储，浏览器关闭后就会删除<br>  还有indexDB等</li></ol></blockquote><hr><blockquote><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>！！！不问我真的没意识到这些知识已经忘光了，欲哭无泪啊！！！</p><ol><li>二叉树的遍历方式有哪些？<br>  前序遍历，中序遍历，后序遍历和层序遍历</li><li>二叉树如何删除一个节点？<br>先确定树的类型，然后找到节点的位置，如果节点是最底层的子节点，就直接置空；如果有一个左子节点或右子节点，则将子节点拼接在要删除的节点的父节点上；如果有左子节点和右子节点，则依序寻找未删除的下一个遍历位置，在不改变原有顺序的情况向将节点进行置换，改变树的结构</li></ol></blockquote><hr><blockquote><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ol><li>简单说一下线程与进程<br>  进程是并发执行的程序在执行过程中分配和管理资源的基本单位，是竞争计算机系统资源的基本单位<br>  线程是进程的一个执行单元，是进程内可调度的一个实体<br>  一个程序至少有一个进程，一个进程至少有一个线程<br>  区别:<br> <em>地址空间</em>：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。<br> <em>资源拥有</em>：同一进程内的线程共享本进程的资源如内存、I&#x2F;O、cpu等，但是进程之间的资源是独立的。<br> <em>开销</em>：线程执行开销小，但是不利于资源的管理和保护。线程适合在SMP机器（双CPU系统）上运行；进程执行开销大，但是能够很好的进行资源管理和保护。进程可以跨机器前移。</li></ol></blockquote><hr><blockquote><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><ol><li>HTTP的状态码及其描述<br>  <code>2**</code>：处理成功<br>  <code>3**</code>：重定向<br>  <code>4**</code>：客户端错误<br>  <code>5**</code>：服务器错误</li></ol></blockquote><table>  <thead>    <tr>      <th>状态码</th>      <th>作用</th>    </tr>  </thead>  <tbody>    <tr>      <td>200</td>      <td>请求成功，服务器成功处理了请求</td>    </tr>    <tr>      <td>201</td>      <td>请求成功，并且服务器新创建了资源</td>    </tr>    <tr>      <td>202</td>      <td>请求成功但服务器尚未处理</td>    </tr>     <tr>      <td>301</td>      <td>永久重定向，页面永久跳转到新的url</td>    </tr>    <tr>      <td>302</td>      <td>临时重定向，服务器目前从不同位置的网页响应请求，但请求仍继续使用原有位置来进行以后的请求</td>    </tr>    <tr>      <td>403</td>      <td>服务器已接收请求，但拒绝处理</td>    </tr>    <tr>      <td>404</td>      <td>页面url未找到</td>    </tr>    <tr>      <td>500</td>      <td>服务器错误</td>    </tr>    <tr>      <td>502</td>      <td>网关错误</td>    </tr>    <tr>      <td>503</td>      <td>由于超载或正在维护，服务器暂时不可用</td>    </tr>  </tbody></table><hr><p>以上就是这次面试的全部题目了，总结一下这次面试：</p><p>全程很紧张，没有什么准备太突然了，暴露了很多缺点，大多数内容只是会用，却没记住，对基础内容掌握还不透彻，对算法，操作系统等大多数之前掌握的知识现在都忘了，也体现了记笔记和记博客的重要性，虽然这次面试很有挫败感，但是也给了我接下来学习的方向和动力，相信努力总是会有回报的！</p>]]></content>
      
      
      <categories>
          
          <category> 校招 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校招 </tag>
            
            <tag> 秋招 </tag>
            
            <tag> 腾讯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初来乍到，请多指教</title>
      <link href="/2020/03/10/%E5%88%9D%E6%9D%A5%E4%B9%8D%E5%88%B0%EF%BC%8C%E8%AF%B7%E5%A4%9A%E6%8C%87%E6%95%99/"/>
      <url>/2020/03/10/%E5%88%9D%E6%9D%A5%E4%B9%8D%E5%88%B0%EF%BC%8C%E8%AF%B7%E5%A4%9A%E6%8C%87%E6%95%99/</url>
      
        <content type="html"><![CDATA[<h2 id="初来乍到，请多指教"><a href="#初来乍到，请多指教" class="headerlink" title="初来乍到，请多指教"></a>初来乍到，请多指教</h2><p>这是我的第一篇博客<br>  中午的一声手机振动吵醒了午睡中的我，域名申请成功，立刻开始了蓄谋已久的计划，第一次上手写博客，本人软件工程专业学生党一枚，出于对技术的好奇心，怀抱对未来的畅想，从现在开始更新博客,记录学习、面试中的重要时刻。</p><p>  记录这一个重要的日子，也希望自己在未来的日子里不忘初心，在学习和生活中都取得好成绩吧！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
